index,lesson_id,task_id,user_id,source_code_1,source_code_2,diff,complexity,breakpoint_lines,final_bp
6,2.0,7.0,diy982m143g18s6fh13npb1y1,"package jetbrains.kotlin.course.first.date

fun main() {
    var firstUserAnswer: String = """"
    var secondUserAnswer: String = """"
    var thirdUserAnswer: String = """"
}
","package jetbrains.kotlin.course.first.date

fun main() {
    println(""Hello! I will ask you several questions."")
    println(""Please answer all of them and be honest with me!"")

    var firstUserAnswer: String = """"
    var secondUserAnswer: String = """"
    var thirdUserAnswer: String = """"
}
","--- 

+++ 

@@ -1,6 +1,9 @@

 package jetbrains.kotlin.course.first.date
 
 fun main() {
+    println(""Hello! I will ask you several questions."")
+    println(""Please answer all of them and be honest with me!"")
+
     var firstUserAnswer: String = """"
     var secondUserAnswer: String = """"
     var thirdUserAnswer: String = """"",Easy,[4],4
8,2.0,7.0,d7g5yofswiqaffhsraihued8z,"package jetbrains.kotlin.course.first.date

fun main() {
    var firstUserAnswer : String
    var secondUserAnswer : String
    var thirdUserAnswer : String
    println(""Hello! I will ask you several questions."")
    println(""Please answer all of them and be honest with me"")
}
","package jetbrains.kotlin.course.first.date

fun main() {
    var firstUserAnswer : String
    var secondUserAnswer : String
    var thirdUserAnswer : String
    println(""Hello! I will ask you several questions."")
    println(""Please answer all of them and be honest with me!"")
}
","--- 

+++ 

@@ -5,6 +5,6 @@

     var secondUserAnswer : String
     var thirdUserAnswer : String
     println(""Hello! I will ask you several questions."")
-    println(""Please answer all of them and be honest with me"")
+    println(""Please answer all of them and be honest with me!"")
 }
 ",Easy,[8],8
10,4.0,23.0,biqh4s8knntgne12yd5ifrpyd,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
        ""Welcome to the game! $newLineSymbol"" +
                newLineSymbol +
                ""Two people play this game: one chooses a word (a sequence of letters), "" +
                ""the other guesses it. In this version, the computer chooses the word: "" +
                ""a sequence of $wordLength letters (for example, $secretExample). "" +
                ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
                ""For each attempt, the number of complete matches (letter and position) "" +
                ""and partial matches (letter only) is reported. $newLineSymbol"" +
                newLineSymbol +
                ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
                ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""
    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    val secret: String = generateSecret()
    playGame(secret, wordLength, maxAttemptsCount)
}

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var complete: Boolean
    do {
        println(""Please input your guess. It should be of length $wordLength."")
        val guess = safeReadLine()
        val esatte: Int = countExactMatches(secret, guess)
        complete = isComplete(secret, guess)
    } while (!complete)
}

fun generateSecret(): String = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int =
        countAllMatches(secret, guess) - countExactMatches(secret, guess)

fun countExactMatches(secret: String, guess: String): Int =
        guess.filterIndexed { index, symbol -> secret[index] == symbol }.length

fun countAllMatches(secret: String, guess: String): Int =
        minOf(guess.filter { it in secret }.length, secret.filter { it in guess }.length)

fun isComplete(secret: String, match: String): Boolean = secret == match

fun printRoundResults(secret: String, guess: String) =
        println(""Your guess has ${countExactMatches(secret, guess)} full matches "" +
                ""and ${countPartialMatches(secret, guess)} partial matches."")

fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean =
        complete && attempts < maxAttemptsCount
","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
        ""Welcome to the game! $newLineSymbol"" +
                newLineSymbol +
                ""Two people play this game: one chooses a word (a sequence of letters), "" +
                ""the other guesses it. In this version, the computer chooses the word: "" +
                ""a sequence of $wordLength letters (for example, $secretExample). "" +
                ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
                ""For each attempt, the number of complete matches (letter and position) "" +
                ""and partial matches (letter only) is reported. $newLineSymbol"" +
                newLineSymbol +
                ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
                ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""
    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    val secret: String = generateSecret()
    playGame(secret, wordLength, maxAttemptsCount)
}

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var complete: Boolean
    do {
        println(""Please input your guess. It should be of length $wordLength."")
        val guess = safeReadLine()
        val esatte: Int = countExactMatches(secret, guess)
        complete = isComplete(secret, guess)
    } while (!complete)
}

fun generateSecret(): String = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int =
        countAllMatches(secret, guess) - countExactMatches(secret, guess)

fun countExactMatches(secret: String, guess: String): Int =
        guess.filterIndexed { index, symbol -> secret[index] == symbol }.length

fun countAllMatches(secret: String, guess: String): Int =
        minOf(guess.filter { it in secret }.length, secret.filter { it in guess }.length)

fun isComplete(secret: String, match: String): Boolean = secret == match

fun printRoundResults(secret: String, guess: String) =
        println(""Your guess has ${countExactMatches(secret, guess)} full matches "" +
                ""and ${countPartialMatches(secret, guess)} partial matches."")

fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean =
        complete && attempts <= maxAttemptsCount
","--- 

+++ 

@@ -51,5 +51,5 @@

                 ""and ${countPartialMatches(secret, guess)} partial matches."")
 
 fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean =
-        complete && attempts < maxAttemptsCount
+        complete && attempts <= maxAttemptsCount
 ",Easy,[54],54
11,4.0,24.0,28r5s8n0aufh33rdcuii7ct3o,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""
fun generateSecret(): String = ""ABCD""
fun isComplete(secret: String, guess: String): Boolean{ 
    return if(secret == guess) {
            true
           }else{
            false
           }
}
fun countPartialMatches(secret: String, guess: String): Int {
    val exactMatches = (countAllMatches(secret, guess)- countExactMatches(secret, guess))
    return exactMatches
}
fun countExactMatches(secret: String, guess: String): Int {
    var count =0
    for(i in 0 until (minOf(secret.length, guess.length))){
        if(secret[i]==guess[i]){
            count++
        }
    }
    return count
}
fun countAllMatches(secret: String, guess: String): Int {
    val matchesG = (secret.filter { it in guess }).length
    val matchesS = (guess.filter { it in secret }).length

    return minOf(matchesG,matchesS)
}
fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int){
    do{
        println(""Please input your guess. It should be of length $wordLength."")
        val guess: String= safeReadLine()

    }while(!isComplete(secret,guess))
}
fun printRoundResults(secret: String, guess: String): Unit {
    val x= countExactMatches(secret, guess)
    val y = countPartialMatches(secret, guess)
    println(""Your guess has $x full matches and $y partial matches."")
}
fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean{
    return if (complete && (attempts<=maxAttemptsCount)){
        true
    } else {
        false
    }
}
fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean{
    return if (complete && (attempts>=maxAttemptsCount)){
        true
    } else {
        false
    }
}
fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""
    val secret = generateSecret()
    println(getGameRules(wordLength,maxAttemptsCount,secretExample))
    playGame(secret, wordLength,maxAttemptsCount)

}
","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""
fun generateSecret(): String = ""ABCD""
fun isComplete(secret: String, guess: String): Boolean{ 
    return if(secret == guess) {
            true
           }else{
            false
           }
}
fun countPartialMatches(secret: String, guess: String): Int {
    val exactMatches = (countAllMatches(secret, guess)- countExactMatches(secret, guess))
    return exactMatches
}
fun countExactMatches(secret: String, guess: String): Int {
    var count =0
    for(i in 0 until (minOf(secret.length, guess.length))){
        if(secret[i]==guess[i]){
            count++
        }
    }
    return count
}
fun countAllMatches(secret: String, guess: String): Int {
    val matchesG = (secret.filter { it in guess }).length
    val matchesS = (guess.filter { it in secret }).length

    return minOf(matchesG,matchesS)
}
fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int){
    do{
        println(""Please input your guess. It should be of length $wordLength."")
        val guess: String= safeReadLine()

    }while(!isComplete(secret,guess))
}
fun printRoundResults(secret: String, guess: String): Unit {
    val x= countExactMatches(secret, guess)
    val y = countPartialMatches(secret, guess)
    println(""Your guess has $x full matches and $y partial matches."")
}
fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean{
    return if (complete && (attempts<=maxAttemptsCount)){
        true
    } else {
        false
    }
}
fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean{
    return if (!complete && (attempts>maxAttemptsCount)){
        true
    } else {
        false
    }
}
fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""
    val secret = generateSecret()
    println(getGameRules(wordLength,maxAttemptsCount,secretExample))
    playGame(secret, wordLength,maxAttemptsCount)

}
","--- 

+++ 

@@ -60,7 +60,7 @@

     }
 }
 fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean{
-    return if (complete && (attempts>=maxAttemptsCount)){
+    return if (!complete && (attempts>maxAttemptsCount)){
         true
     } else {
         false",Easy,"[63,64,66]",63
12,3.0,3.0,6no2z5fdvvvzxvy1cb0nc9gkh,"package jetbrains.kotlin.course.chat

fun main() {
    // Write your solution here
    println(""Hello! I'm glad to meet you, let me get to know you better! What is your name?"")
    val userName:String? = readlnOrNull()
    println(""Nice to meet you, $userName! My name is Kotlin Bot! I am a young programming language created in 2010. How old are you?"")
}
","package jetbrains.kotlin.course.chat

fun main() {
    // Write your solution here
    println(""Hello! I'm glad to meet you, let me get to know you better! What is your name?"")
    val userName:String? = readlnOrNull()
    println(""Nice to meet you, $userName! My name is Kotlin Bot! I am a young programming language created in 2010. How old are you?"")
    val userAge:String? = readlnOrNull()
}
","--- 

+++ 

@@ -5,5 +5,6 @@

     println(""Hello! I'm glad to meet you, let me get to know you better! What is your name?"")
     val userName:String? = readlnOrNull()
     println(""Nice to meet you, $userName! My name is Kotlin Bot! I am a young programming language created in 2010. How old are you?"")
+    val userAge:String? = readlnOrNull()
 }
 ",Easy,[5],5
20,4.0,27.0,2r5g5bu8guw5xzw1pm74df9tq,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun generateSecret(): String {
    return ""ABCD""
}

fun printRoundResults(secret: String, guess: String): Unit {
    val fullMachtes = countExactMatches(secret, guess)
    val partialMatches = countPartialMatches(secret, guess)
    println(""Your guess has $fullMachtes full matches and $partialMatches partial matches."")
}

fun countPartialMatches(secret: String, guess: String): Int =
    countAllMatches(secret, guess) - countExactMatches(secret, guess)

fun countExactMatches(secret: String, guess: String): Int {
    var result = """"
    result = guess.filterIndexed { index, symbol -> secret[index] == symbol }
    return result.length
}

fun countAllMatches(secret: String, guess: String): Int {
    val secretList = secret.toList()
    val guessList = guess.toList()
    val numberMachtesLeft = secretList.filter { it in guessList }.size
    val numberMachtesRight = guessList.filter { it in secretList }.size
    return minOf(numberMachtesLeft, numberMachtesRight)
}


fun isComplete(secret: String, guess: String): Boolean = secret == guess

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int): Unit {
    var countAttempts = 0
    do {
       println(""Please input your guess. It should be of length $wordLength."")
       val guess = safeReadLine()
        countAttempts++
        printRoundResults(secret, guess)
        if (isLost(isComplete(secret, guess), countAttempts, maxAttemptsCount)){
            println(""Sorry, you lost! :( My word is $secret"")
        } else if (isWon(isComplete(secret, guess), countAttempts, maxAttemptsCount)){
            println(""Congratulations! You guessed it!"")
        }
    } while (!isComplete(secret, guess) || countAttempts > maxAttemptsCount)
}

fun isWon(complete: Boolean, attemps: Int, maxAttemptsCount: Int): Boolean {
    var won = false
    if(complete && attemps <= maxAttemptsCount){
        won = true
    }
    return won
}

fun isLost(complete: Boolean, attemps: Int, maxAttemptsCount: Int): Boolean {
    var lost = true
    if (!complete && attemps > maxAttemptsCount){
        lost = true
    } else {
        lost = false
    }
    return lost
}

fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""
    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    val secret: String = generateSecret()
     playGame(secret, wordLength, maxAttemptsCount)

}
","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun generateSecret(): String {
    return ""ABCD""
}

fun printRoundResults(secret: String, guess: String): Unit {
    val fullMachtes = countExactMatches(secret, guess)
    val partialMatches = countPartialMatches(secret, guess)
    println(""Your guess has $fullMachtes full matches and $partialMatches partial matches."")
}

fun countPartialMatches(secret: String, guess: String): Int =
    countAllMatches(secret, guess) - countExactMatches(secret, guess)

fun countExactMatches(secret: String, guess: String): Int {
    var result = """"
    result = guess.filterIndexed { index, symbol -> secret[index] == symbol }
    return result.length
}

fun countAllMatches(secret: String, guess: String): Int {
    val secretList = secret.toList()
    val guessList = guess.toList()
    val numberMachtesLeft = secretList.filter { it in guessList }.size
    val numberMachtesRight = guessList.filter { it in secretList }.size
    return minOf(numberMachtesLeft, numberMachtesRight)
}


fun isComplete(secret: String, guess: String): Boolean = secret == guess

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int): Unit {
    var countAttempts = 0
    do {
       println(""Please input your guess. It should be of length $wordLength."")
       val guess = safeReadLine()
        countAttempts++
        printRoundResults(secret, guess)
        if (isLost(isComplete(secret, guess), countAttempts, maxAttemptsCount)){
            println(""Sorry, you lost! :( My word is $secret"")
        } else if (isWon(isComplete(secret, guess), countAttempts, maxAttemptsCount)){
            println(""Congratulations! You guessed it!"")
        }
    } while (!isComplete(secret, guess) && countAttempts <= maxAttemptsCount)
}

fun isWon(complete: Boolean, attemps: Int, maxAttemptsCount: Int): Boolean {
    var won = false
    if(complete && attemps <= maxAttemptsCount){
        won = true
    }
    return won
}

fun isLost(complete: Boolean, attemps: Int, maxAttemptsCount: Int): Boolean {
    var lost = true
    if (!complete && attemps > maxAttemptsCount){
        lost = true
    } else {
        lost = false
    }
    return lost
}

fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""
    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    val secret: String = generateSecret()
     playGame(secret, wordLength, maxAttemptsCount)

}
","--- 

+++ 

@@ -56,7 +56,7 @@

         } else if (isWon(isComplete(secret, guess), countAttempts, maxAttemptsCount)){
             println(""Congratulations! You guessed it!"")
         }
-    } while (!isComplete(secret, guess) || countAttempts > maxAttemptsCount)
+    } while (!isComplete(secret, guess) && countAttempts <= maxAttemptsCount)
 }
 
 fun isWon(complete: Boolean, attemps: Int, maxAttemptsCount: Int): Boolean {",Middle,"[51,52,59,87]",59
22,8.0,7.0,2gmmru8bnub1fkr6hb1z0qykt,"package jetbrains.kotlin.course.last.push

import kotlin.system.exitProcess

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }
    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append(fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    // println(patternWidth * width + newLineSymbol.length)

    val pattern = line.drop(patternWidth * width + newLineSymbol.length)
    // pattern = pattern.replace(""+------+'   "", ""+------+'"")
    return pattern

    //return """"
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()

    if (getPatternHeight(pattern) > 0) {
        val patternWidth = getPatternWidth(pattern)
        val patternHeight = getPatternHeight(pattern)
        val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
        val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)
        output.append(repeatedPattern)

        for (i in 1 until height) {
            output.append(dropped)
        }
    }

    return output.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()
    // return repeatHorizontally(rhombus, 5, 10)

    if (getPatternHeight(pattern) != 1) {

        //output.append(width)
        // foreach line och kör line.length för att få rätt mellan rum.

        // println(repeatHorizontallyWithGaps(pattern, height, width))

        //output.append(repeatHorizontally(pattern, width, getPatternHeight(pattern)+3))
        var odd = false
        output.append(repeatHorizontallyWithGaps(pattern, width, height))
    }

    if (getPatternHeight(pattern) == 1 && width < 3) {
        output.append(fillPatternRow(pattern, width))
        //output.append(repeatHorizontally(pattern, width, height))
        for (i in 1 until height) {
            output.append(newLineSymbol)
            output.append(fillPatternRow(pattern, width))
            //output.append(repeatHorizontally(pattern, width, height))
        }
    } else if (width > 3 && width != 7) {
        for (i in 0 until height) {

            output.append(newLineSymbol)
            var widthToDrop = 3
            if (i % 2 != 0) {
                // ODD
                var repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                repeatedPattern = repeatedPattern.dropLast(repeatedPattern.length-width+pattern.length)
                repeatedPattern = separator + repeatedPattern
                output.append(repeatedPattern)
            } else {
                // EVEN
                val repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                output.append(repeatedPattern.dropLast(width+1))
            }

        }
    }

    return output.toString()
}


fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    //var theOdd = odd
    var odd = false
    var odz = 0
    for (xPattern in 1..patternWidth) {
        for ((index, p) in pattern.lines().withIndex()) {
            if (n > 1) {
                odz = (if (xPattern % 2 == 0) 0 else 1)
            }
            println(xPattern)
            for (i in 0 until n) {
                if (i % 2 == odz) {
                    output.append(""$separator"".repeat(getPatternWidth(pattern)))
                } else {
                    output.append(p + ""$separator"".repeat(getPatternWidth(pattern) - p.length))
                }
            }
            output.append(newLineSymbol)
        }
    }

    return output.toString()
}

fun main() {

    // println(canvasWithGapsGenerator(ball, 2,1))

    println(canvasWithGapsGenerator(rhombus, 5,7))
    //println(repeatHorizontallyWithGaps(rhombus, 5, 7))

    //println(canvasGenerator(""○○"", 5,1))
    // println(canvasGenerator(rhombus, 5,3))



    exitProcess(1)
    println(canvasWithGapsGenerator(rhombus, 1,1))
    exitProcess(1)

    println(canvasGenerator(rhombus, 5,5))
    exitProcess(1)
    //println(dropTopFromLine(repeatHorizontally(rhombus, 1, getPatternWidth(rhombus)), 1, getPatternWidth(rhombus), getPatternHeight(rhombus)))
    //exitProcess(1)

    println(rhombus)
    println(""___"")
    val patternWidth = getPatternWidth(rhombus)
    val patternHeight = getPatternHeight(rhombus)
    val repeatedPattern = repeatHorizontally(rhombus, 5, patternWidth)
    println(repeatedPattern)
    val dropped = dropTopFromLine(repeatedPattern, 5, patternHeight, patternWidth)
    println(dropped)
    //println(repeatedPattern + dropped + dropped)

    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

import kotlin.system.exitProcess

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }
    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append(fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    // println(patternWidth * width + newLineSymbol.length)

    val pattern = line.drop(patternWidth * width + newLineSymbol.length)
    // pattern = pattern.replace(""+------+'   "", ""+------+'"")
    return pattern

    //return """"
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()

    if (getPatternHeight(pattern) > 0) {
        val patternWidth = getPatternWidth(pattern)
        val patternHeight = getPatternHeight(pattern)
        val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
        val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)
        output.append(repeatedPattern)

        for (i in 1 until height) {
            output.append(dropped)
        }
    }

    return output.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()
    // return repeatHorizontally(rhombus, 5, 10)

    if (getPatternHeight(pattern) != 1) {

        //output.append(width)
        // foreach line och kör line.length för att få rätt mellan rum.

        // println(repeatHorizontallyWithGaps(pattern, height, width))

        //output.append(repeatHorizontally(pattern, width, getPatternHeight(pattern)+3))
        var odd = false
        output.append(repeatHorizontallyWithGaps(pattern, width, height))
    }

    if (getPatternHeight(pattern) == 1 && width < 3) {
        output.append(fillPatternRow(pattern, width))
        //output.append(repeatHorizontally(pattern, width, height))
        for (i in 1 until height) {
            output.append(newLineSymbol)
            output.append(fillPatternRow(pattern, width))
            //output.append(repeatHorizontally(pattern, width, height))
        }
    } else if (width > 3 && width != 7) {
        for (i in 0 until height) {

            output.append(newLineSymbol)
            var widthToDrop = 3
            if (i % 2 != 0) {
                // ODD
                var repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                repeatedPattern = repeatedPattern.dropLast(repeatedPattern.length-width+pattern.length)
                repeatedPattern = separator + repeatedPattern
                output.append(repeatedPattern)
            } else {
                // EVEN
                val repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                output.append(repeatedPattern.dropLast(width+1))
            }

        }
    }

    return output.toString()
}


fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    //var theOdd = odd
    var odd = false
    var odz = 1
    for (xPattern in 1..patternWidth) {
        for ((index, p) in pattern.lines().withIndex()) {
            if (n > 1) {
                odz = (if (xPattern % 2 == 0) 0 else 1)
            }
            println(xPattern)
            for (i in 0 until n) {
                if (i % 2 == odz) {
                    output.append(""$separator"".repeat(getPatternWidth(pattern)))
                } else {
                    output.append(p + ""$separator"".repeat(getPatternWidth(pattern) - p.length))
                }
            }
            output.append(newLineSymbol)
        }
    }

    return output.toString()
}

fun main() {

    // println(canvasWithGapsGenerator(ball, 2,1))

    println(canvasWithGapsGenerator(rhombus, 5,7))
    //println(repeatHorizontallyWithGaps(rhombus, 5, 7))

    //println(canvasGenerator(""○○"", 5,1))
    // println(canvasGenerator(rhombus, 5,3))



    exitProcess(1)
    println(canvasWithGapsGenerator(rhombus, 1,1))
    exitProcess(1)

    println(canvasGenerator(rhombus, 5,5))
    exitProcess(1)
    //println(dropTopFromLine(repeatHorizontally(rhombus, 1, getPatternWidth(rhombus)), 1, getPatternWidth(rhombus), getPatternHeight(rhombus)))
    //exitProcess(1)

    println(rhombus)
    println(""___"")
    val patternWidth = getPatternWidth(rhombus)
    val patternHeight = getPatternHeight(rhombus)
    val repeatedPattern = repeatHorizontally(rhombus, 5, patternWidth)
    println(repeatedPattern)
    val dropped = dropTopFromLine(repeatedPattern, 5, patternHeight, patternWidth)
    println(dropped)
    //println(repeatedPattern + dropped + dropped)

    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -162,7 +162,7 @@

     val output = StringBuilder()
     //var theOdd = odd
     var odd = false
-    var odz = 0
+    var odz = 1
     for (xPattern in 1..patternWidth) {
         for ((index, p) in pattern.lines().withIndex()) {
             if (n > 1) {",Hard,"[126,165,169,173,183]",165
24,8.0,5.0,5j0jn97sij12c907xijke67is,"package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun main() {
    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}

fun getPatternHeight (pattern:String):Int = pattern.lines().size

fun fillPatternRow (patternRow:String, patternWidth:Int):String {
    check(patternRow.length <= patternWidth)
    return patternRow + List(patternWidth - patternRow.length) { separator }.joinToString("""")
}

fun repeatHorizontally (pattern:String, n:Int, patternWidth: Int):String {
    val output = StringBuilder()
    pattern.lines().forEach {
        val patternRow = fillPatternRow(it, patternWidth)
        output.append(List(n) {patternRow}.joinToString ( """" ))
        output.append('\n')
    }
    return output.toString().take(output.length - 1)
}

fun dropTopFromLine (line:String, width:Int, patternHeight:Int, patternWidth:Int):String {
    if (patternHeight == 1) return line

    return line.lines().drop(1).joinToString(System.lineSeparator())
}
","package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun main() {
    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}

fun getPatternHeight (pattern:String):Int = pattern.lines().size

fun fillPatternRow (patternRow:String, patternWidth:Int):String {
    check(patternRow.length <= patternWidth)
    return patternRow + List(patternWidth - patternRow.length) { separator }.joinToString("""")
}

fun repeatHorizontally (pattern:String, n:Int, patternWidth: Int):String {
    val output = StringBuilder()
    pattern.lines().forEach {
        val patternRow = fillPatternRow(it, patternWidth)
        output.append(List(n) {patternRow}.joinToString ( """" ))
        output.append('\n')
    }
    return output.toString().take(output.length - 1)
}

fun dropTopFromLine (line:String, width:Int, patternHeight:Int, patternWidth:Int):String {
    if (patternHeight == 1) return line

    return line.lines().drop(1).joinToString(""\n"")
}
","--- 

+++ 

@@ -88,6 +88,6 @@

 fun dropTopFromLine (line:String, width:Int, patternHeight:Int, patternWidth:Int):String {
     if (patternHeight == 1) return line
 
-    return line.lines().drop(1).joinToString(System.lineSeparator())
+    return line.lines().drop(1).joinToString(""\n"")
 }
 ",Hard,[91],91
30,7.0,12.0,7w31c6krq7xxlcdy7yhphet0v,"package jetbrains.kotlin.course.almost.done

fun trimPicture(picture: String): String = picture.trimIndent()

fun applyBordersFilter(picture: String): String {
    val finalPicture = StringBuilder()
    val pictureWidth = getPictureWidth(picture)
    val topBottom = borderSymbol.toString().repeat(pictureWidth + 4)
    finalPicture.append(topBottom)
    finalPicture.append(""\n"")
    for (line in picture.lines()) {
        val extraPaddingCount = pictureWidth - line.length
        val newLine = StringBuilder()
        newLine.append(borderSymbol)
        newLine.append(separator)
        newLine.append(line)
        newLine.append(separator.toString().repeat(1+extraPaddingCount))
        newLine.append(borderSymbol)
        finalPicture.append(newLine.toString())
        finalPicture.append(""\n"")
    }
    finalPicture.append(topBottom)
    return finalPicture.toString()

}

fun applySquaredFilter(picture: String): String {
    val finalPicture = StringBuilder()
    val pictureWidth = getPictureWidth(picture)
    val topBottom = borderSymbol.toString().repeat((pictureWidth + 4) * 2)
    for (i in 1..2) {
        finalPicture.append(topBottom)
        finalPicture.append(""\n"")
        for (line in picture.lines()) {
            val extraPaddingCount = pictureWidth - line.length
            val newLine = StringBuilder()
            newLine.append(borderSymbol)
            newLine.append(separator)
            newLine.append(line)
            newLine.append(separator.toString().repeat(1 + extraPaddingCount))
            newLine.append(borderSymbol)
            finalPicture.append(newLine.toString())
            finalPicture.append(newLine.toString())
            finalPicture.append(""\n"")
        }
        finalPicture.append(topBottom)
        finalPicture.append(""\n"")
    }
    return finalPicture.toString()

}

fun applyFilter(picture: String, filter: String): String {
    return when (filter) {
        ""borders"" -> applyBordersFilter(picture)
        ""squared"" -> applySquaredFilter(picture)
        else -> error(""Invalid filter"")
    }
} 

fun main() {
    // Uncomment this code on the last step of the game

    // photoshop()
}
","package jetbrains.kotlin.course.almost.done

fun trimPicture(picture: String): String = picture.trimIndent()

fun applyBordersFilter(picture: String): String {
    val finalPicture = StringBuilder()
    val pictureWidth = getPictureWidth(picture)
    val topBottom = borderSymbol.toString().repeat(pictureWidth + 4)
    finalPicture.append(topBottom)
    finalPicture.append(""\n"")
    for (line in picture.lines()) {
        val extraPaddingCount = pictureWidth - line.length
        val newLine = StringBuilder()
        newLine.append(borderSymbol)
        newLine.append(separator)
        newLine.append(line)
        newLine.append(separator.toString().repeat(1+extraPaddingCount))
        newLine.append(borderSymbol)
        finalPicture.append(newLine.toString())
        finalPicture.append(""\n"")
    }
    finalPicture.append(topBottom)
    return finalPicture.toString()

}

fun applySquaredFilter(picture: String): String {
    val finalPicture = StringBuilder()
    val pictureWidth = getPictureWidth(picture)
    val topBottom = borderSymbol.toString().repeat((pictureWidth + 4) * 2)
    for (i in 1..2) {
        finalPicture.append(topBottom)
        finalPicture.append(""\n"")
        for (line in picture.lines()) {
            val extraPaddingCount = pictureWidth - line.length
            val newLine = StringBuilder()
            newLine.append(borderSymbol)
            newLine.append(separator)
            newLine.append(line)
            newLine.append(separator.toString().repeat(1 + extraPaddingCount))
            newLine.append(borderSymbol)
            finalPicture.append(newLine.toString())
            finalPicture.append(newLine.toString())
            finalPicture.append(""\n"")
        }
    }
    finalPicture.append(topBottom)
    return finalPicture.toString()

}

fun applyFilter(picture: String, filter: String): String {
    return when (filter) {
        ""borders"" -> applyBordersFilter(picture)
        ""squared"" -> applySquaredFilter(picture)
        else -> error(""Invalid filter"")
    }
} 

fun main() {
    // Uncomment this code on the last step of the game

    // photoshop()
}
","--- 

+++ 

@@ -43,9 +43,8 @@

             finalPicture.append(newLine.toString())
             finalPicture.append(""\n"")
         }
-        finalPicture.append(topBottom)
-        finalPicture.append(""\n"")
     }
+    finalPicture.append(topBottom)
     return finalPicture.toString()
 
 }",Hard,"[46,47,49,56]",46
31,7.0,12.0,dnwyob4jion1nirkcwd5343vy,"package jetbrains.kotlin.course.almost.done
fun trimPicture(picture: String): String{
    return picture.trimIndent()
}
fun applyBordersFilter(picture: String): String{
    val width= getPictureWidth(picture)
    val newpicture=StringBuilder()
    newpicture.append(""$borderSymbol"".repeat(width+4))
    newpicture.append(""$newLineSymbol"")
    for (line in picture.lines()){
        val newline=StringBuilder()
        newline.append(""$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol"")
        newline.append(""$newLineSymbol"")
        val new =newline.toString()
        newpicture.append(newline)
    }
    newpicture.append(""$borderSymbol"".repeat(width+4))
    val newpic=newpicture.toString()
    return newpic
}
fun applySquaredFilter(picture: String): String{
    val width= getPictureWidth(picture)
    val newpicture=StringBuilder()
    newpicture.append(""$borderSymbol"".repeat(width*2+8))
    newpicture.append(""$newLineSymbol"")
    for (line in picture.lines()){
        val newline=StringBuilder()
        newline.append(""$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol"")
        newline.append(""$newLineSymbol"")
        val new =newline.toString()
        newpicture.append(newline)
    }
    newpicture.append(""$borderSymbol"".repeat(width*2+8))
    for (line in picture.lines()){
        val newline=StringBuilder()
        newline.append(""$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol"")
        newline.append(""$newLineSymbol"")
        val new =newline.toString()
        newpicture.append(newline)
    }
    newpicture.append(""$borderSymbol"".repeat(width*2+8))
    val newpic=newpicture.toString()
    return newpic
}
fun applyFilter(picture: String, filter: String): String{
    return when(filter){
        ""borders""-> applyBordersFilter(trimPicture(picture))
        ""squared""-> applySquaredFilter(trimPicture(picture))
        else->{
            println(""error"")
            picture
        }
    }
}
fun main() {
    // Uncomment this code on the last step of the game

    // photoshop()
}
","package jetbrains.kotlin.course.almost.done
fun trimPicture(picture: String): String{
    return picture.trimIndent()
}
fun applyBordersFilter(picture: String): String{
    val width= getPictureWidth(picture)
    val newpicture=StringBuilder()
    newpicture.append(""$borderSymbol"".repeat(width+4))
    newpicture.append(""$newLineSymbol"")
    for (line in picture.lines()){
        val newline=StringBuilder()
        newline.append(""$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol"")
        newline.append(""$newLineSymbol"")
        val new =newline.toString()
        newpicture.append(newline)
    }
    newpicture.append(""$borderSymbol"".repeat(width+4))
    val newpic=newpicture.toString()
    return newpic
}
fun applySquaredFilter(picture: String): String{
    val width= getPictureWidth(picture)
    val newpicture=StringBuilder()
    newpicture.append(""$borderSymbol"".repeat(width*2+8))
    newpicture.append(""$newLineSymbol"")
    for (line in picture.lines()){
        val newline=StringBuilder()
        newline.append(""$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol"")
        newline.append(""$newLineSymbol"")
        val new =newline.toString()
        newpicture.append(newline)
    }
    newpicture.append(""$borderSymbol"".repeat(width*2+8))
    newpicture.append(""$newLineSymbol"")
    for (line in picture.lines()){
        val newline=StringBuilder()
        newline.append(""$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol$borderSymbol$separator"")
        newline.append(line)
        newline.append(""$separator"".repeat(width-line.length+1))
        newline.append(""$borderSymbol"")
        newline.append(""$newLineSymbol"")
        val new =newline.toString()
        newpicture.append(newline)
    }
    newpicture.append(""$borderSymbol"".repeat(width*2+8))
    val newpic=newpicture.toString()
    return newpic
}
fun applyFilter(picture: String, filter: String): String{
    return when(filter){
        ""borders""-> applyBordersFilter(trimPicture(picture))
        ""squared""-> applySquaredFilter(trimPicture(picture))
        else->{
            println(""error"")
            picture
        }
    }
}
fun main() {
    // Uncomment this code on the last step of the game

    // photoshop()
}
","--- 

+++ 

@@ -40,6 +40,7 @@

         newpicture.append(newline)
     }
     newpicture.append(""$borderSymbol"".repeat(width*2+8))
+    newpicture.append(""$newLineSymbol"")
     for (line in picture.lines()){
         val newline=StringBuilder()
         newline.append(""$borderSymbol$separator"")",Hard,"[43,54,57,63]",43
34,6.0,3.0,5gzp30z0o85hvysz99q9zucai,"package jetbrains.kotlin.course.hangman

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int) = ""Welcome to the game!$newLineSymbol$newLineSymbol"" +
        ""In this game, you need to guess the word made by the computer.$newLineSymbol"" +
        ""The hidden word will appear as a sequence of underscores, one underscore means one letter.$newLineSymbol"" +
        ""You have $maxAttemptsCount attempts to guess the word.$newLineSymbol"" +
        ""All words are English words, consisting of $wordLength letters.$newLineSymbol"" +
        ""Each attempt you should enter any one letter,$newLineSymbol"" +
        ""if it is in the hidden word, all matches will be guessed.$newLineSymbol$newLineSymbol"" +
        """" +
        ""For example, if the word \""CAT\"" was guessed, \""_ _ _\"" will be displayed first, "" +
        ""since the word has 3 letters.$newLineSymbol"" +
        ""If you enter the letter A, you will see \""_ A _\"" and so on.$newLineSymbol$newLineSymbol"" +
        """" +
        ""Good luck in the game!""

// You will use this function later
fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int) = complete && attempts <= maxAttemptsCount

// You will use this function later
fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int) = !complete && attempts > maxAttemptsCount

fun isComplete(secret: String, currentGuess: String) = secret == currentGuess.split(separator).joinToString("""")

fun generateNewUserWord(secret: String, guess: Char, currentUserWord: String) : String {
    val res = List(secret.length) { '_' }.toMutableList()
    val splittedWord = currentUserWord.split("" "").toString()
    for (i in splittedWord.indices){
        res[i] = if (secret[i] == guess){
            guess
        } else {
            splittedWord[i]
        }
    }
    return res.joinToString("" "")
}

fun main() {
    // Uncomment this code on the last step of the game

    // println(getGameRules(wordLength, maxAttemptsCount))
    // playGame(generateSecret(), maxAttemptsCount)
}
","package jetbrains.kotlin.course.hangman

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int) = ""Welcome to the game!$newLineSymbol$newLineSymbol"" +
        ""In this game, you need to guess the word made by the computer.$newLineSymbol"" +
        ""The hidden word will appear as a sequence of underscores, one underscore means one letter.$newLineSymbol"" +
        ""You have $maxAttemptsCount attempts to guess the word.$newLineSymbol"" +
        ""All words are English words, consisting of $wordLength letters.$newLineSymbol"" +
        ""Each attempt you should enter any one letter,$newLineSymbol"" +
        ""if it is in the hidden word, all matches will be guessed.$newLineSymbol$newLineSymbol"" +
        """" +
        ""For example, if the word \""CAT\"" was guessed, \""_ _ _\"" will be displayed first, "" +
        ""since the word has 3 letters.$newLineSymbol"" +
        ""If you enter the letter A, you will see \""_ A _\"" and so on.$newLineSymbol$newLineSymbol"" +
        """" +
        ""Good luck in the game!""

// You will use this function later
fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int) = complete && attempts <= maxAttemptsCount

// You will use this function later
fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int) = !complete && attempts > maxAttemptsCount

fun isComplete(secret: String, currentGuess: String) = secret == currentGuess.split(separator).joinToString("""")

fun generateNewUserWord(secret: String, guess: Char, currentUserWord: String) : String {
    val res = List(secret.length) { '_' }.toMutableList()
    val splittedWord = currentUserWord.split("" "").joinToString("""")
    for (i in splittedWord.indices){
        res[i] = if (secret[i] == guess){
            guess
        } else {
            splittedWord[i]
        }
    }
    return res.joinToString("" "")
}

fun main() {
    // Uncomment this code on the last step of the game

    // println(getGameRules(wordLength, maxAttemptsCount))
    // playGame(generateSecret(), maxAttemptsCount)
}
","--- 

+++ 

@@ -25,7 +25,7 @@

 
 fun generateNewUserWord(secret: String, guess: Char, currentUserWord: String) : String {
     val res = List(secret.length) { '_' }.toMutableList()
-    val splittedWord = currentUserWord.split("" "").toString()
+    val splittedWord = currentUserWord.split("" "").joinToString("""")
     for (i in splittedWord.indices){
         res[i] = if (secret[i] == guess){
             guess",Middle,"[28,29,33]",28
40,8.0,7.0,2gmmru8bnub1fkr6hb1z0qykt,"package jetbrains.kotlin.course.last.push

import kotlin.system.exitProcess

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }
    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append(fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    // println(patternWidth * width + newLineSymbol.length)

    val pattern = line.drop(patternWidth * width + newLineSymbol.length)
    // pattern = pattern.replace(""+------+'   "", ""+------+'"")
    return pattern

    //return """"
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()

    if (getPatternHeight(pattern) > 0) {
        val patternWidth = getPatternWidth(pattern)
        val patternHeight = getPatternHeight(pattern)
        val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
        val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)
        output.append(repeatedPattern)

        for (i in 1 until height) {
            output.append(dropped)
        }
    }

    return output.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()
    // return repeatHorizontally(rhombus, 5, 10)

    if (getPatternHeight(pattern) == 1) {
        output.append(fillPatternRow(pattern, width))
        //output.append(repeatHorizontally(pattern, width, height))
        for (i in 1 until height) {
            output.append(newLineSymbol)
            output.append(fillPatternRow(pattern, width))
            output.append(repeatHorizontally(pattern, width, height))
        }
    } else {
        for (i in 1 until height) {
            val patternWidth = getPatternWidth(pattern)
            val patternHeight = getPatternHeight(pattern)
            val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
            output.append(repeatedPattern)
        }
    }
        //return fillPatternRow(pattern, width)
    //}

    //for (p in pattern.lines())

    //return repeatHorizontally(pattern, width, height)

    return output.toString()
}

fun main() {

    println(canvasWithGapsGenerator(ball, 2,1))
    exitProcess(1)

    println(canvasGenerator(rhombus, 5,5))
    exitProcess(1)
    //println(dropTopFromLine(repeatHorizontally(rhombus, 1, getPatternWidth(rhombus)), 1, getPatternWidth(rhombus), getPatternHeight(rhombus)))
    //exitProcess(1)

    println(rhombus)
    println(""___"")
    val patternWidth = getPatternWidth(rhombus)
    val patternHeight = getPatternHeight(rhombus)
    val repeatedPattern = repeatHorizontally(rhombus, 5, patternWidth)
    println(repeatedPattern)
    val dropped = dropTopFromLine(repeatedPattern, 5, patternHeight, patternWidth)
    println(dropped)
    //println(repeatedPattern + dropped + dropped)

    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

import kotlin.system.exitProcess

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }
    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append(fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    // println(patternWidth * width + newLineSymbol.length)

    val pattern = line.drop(patternWidth * width + newLineSymbol.length)
    // pattern = pattern.replace(""+------+'   "", ""+------+'"")
    return pattern

    //return """"
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()

    if (getPatternHeight(pattern) > 0) {
        val patternWidth = getPatternWidth(pattern)
        val patternHeight = getPatternHeight(pattern)
        val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
        val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)
        output.append(repeatedPattern)

        for (i in 1 until height) {
            output.append(dropped)
        }
    }

    return output.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()
    // return repeatHorizontally(rhombus, 5, 10)

    if (getPatternHeight(pattern) == 1) {
        output.append(fillPatternRow(pattern, width))
        //output.append(repeatHorizontally(pattern, width, height))
        for (i in 1 until height) {
            output.append(newLineSymbol)
            output.append(fillPatternRow(pattern, width))
            //output.append(repeatHorizontally(pattern, width, height))
        }
    } else {
        for (i in 1 until height) {
            val patternWidth = getPatternWidth(pattern)
            val patternHeight = getPatternHeight(pattern)
            val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
            output.append(repeatedPattern)
        }
    }
        //return fillPatternRow(pattern, width)
    //}

    //for (p in pattern.lines())

    //return repeatHorizontally(pattern, width, height)

    return output.toString()
}

fun main() {

    println(canvasWithGapsGenerator(ball, 2,1))
    exitProcess(1)

    println(canvasGenerator(rhombus, 5,5))
    exitProcess(1)
    //println(dropTopFromLine(repeatHorizontally(rhombus, 1, getPatternWidth(rhombus)), 1, getPatternWidth(rhombus), getPatternHeight(rhombus)))
    //exitProcess(1)

    println(rhombus)
    println(""___"")
    val patternWidth = getPatternWidth(rhombus)
    val patternHeight = getPatternHeight(rhombus)
    val repeatedPattern = repeatHorizontally(rhombus, 5, patternWidth)
    println(repeatedPattern)
    val dropped = dropTopFromLine(repeatedPattern, 5, patternHeight, patternWidth)
    println(dropped)
    //println(repeatedPattern + dropped + dropped)

    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -120,7 +120,7 @@

         for (i in 1 until height) {
             output.append(newLineSymbol)
             output.append(fillPatternRow(pattern, width))
-            output.append(repeatHorizontally(pattern, width, height))
+            //output.append(repeatHorizontally(pattern, width, height))
         }
     } else {
         for (i in 1 until height) {",Hard,"[123,140,145]",123
41,8.0,7.0,mhk7jwcz204cbk8o9h0wgmm0,"package jetbrains.kotlin.course.last.push

import org.intellij.lang.annotations.Pattern

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow : String, patternWidth : Int): String {
    check(patternRow.count() <= patternWidth)
    return patternRow + ""$separator"".repeat(patternWidth-patternRow.count())
}

fun repeatHorizontally(pattern: String, repeats : Int, patternWidth: Int): String {
    val result = StringBuilder()
    pattern.lines().forEachIndexed { index, x ->
        result.append(fillPatternRow(x,patternWidth).repeat(repeats))
        if (index < pattern.lines().size - 1)
            result.append(""\n"")
    }
    return result.toString()
}

fun dropTopFromLine(line: String, width:Int, patternHeight:Int, patternWidth:Int):String {
    if(patternHeight==1)return line
    return line.drop(width*patternWidth+1)
}

fun canvasGenerator(pattern: String, width: Int, height:Int):String {
    val result = StringBuilder()
    result.append(repeatHorizontally(pattern,width, getPatternWidth(pattern)))
    val repeatedPattern = result.toString()
    for(i in 1 until height){
        result.append(newLineSymbol + dropTopFromLine(repeatedPattern,width, getPatternHeight(pattern), getPatternWidth(pattern)))
    }
    return result.toString()
}

fun repeatHorizontallyWithGaps(pattern: String, repeats: Int, parity: Boolean): String {
    if(getPatternHeight(pattern)==1)return repeatHorizontally(pattern,repeats, getPatternWidth(pattern))
    val result = StringBuilder()
    for(x in pattern.lines()){
        for(i in 1..repeats){
            result.append(if((i%2==1)==parity) x else ""$separator"".repeat(x.length))
        }
        result.append(newLineSymbol)
    }
    println(result.toString())
    return result.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int):String {
    val result = StringBuilder()
    for( i in 1..height){
        result.append(repeatHorizontallyWithGaps(pattern,width,i%2==1))
        if(i<height)result.append(newLineSymbol)
    }
    return result.toString()
}

fun main() {
    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

import org.intellij.lang.annotations.Pattern

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow : String, patternWidth : Int): String {
    check(patternRow.count() <= patternWidth)
    return patternRow + ""$separator"".repeat(patternWidth-patternRow.count())
}

fun repeatHorizontally(pattern: String, repeats : Int, patternWidth: Int): String {
    val result = StringBuilder()
    pattern.lines().forEachIndexed { index, x ->
        result.append(fillPatternRow(x,patternWidth).repeat(repeats))
        if (index < pattern.lines().size - 1)
            result.append(""\n"")
    }
    return result.toString()
}

fun dropTopFromLine(line: String, width:Int, patternHeight:Int, patternWidth:Int):String {
    if(patternHeight==1)return line
    return line.drop(width*patternWidth+1)
}

fun canvasGenerator(pattern: String, width: Int, height:Int):String {
    val result = StringBuilder()
    result.append(repeatHorizontally(pattern,width, getPatternWidth(pattern)))
    val repeatedPattern = result.toString()
    for(i in 1 until height){
        result.append(newLineSymbol + dropTopFromLine(repeatedPattern,width, getPatternHeight(pattern), getPatternWidth(pattern)))
    }
    return result.toString()
}

fun repeatHorizontallyWithGaps(pattern: String, repeats: Int, parity: Boolean): String {
    //if(getPatternHeight(pattern)==1 && ==1)return repeatHorizontally(pattern,repeats, getPatternWidth(pattern))
    if(repeats==1)return pattern
    val result = StringBuilder()
    for(x in pattern.lines()){
        for(i in 1..repeats){
            result.append(if((i%2==1)==parity) x else ""$separator"".repeat(x.length))
        }
        result.append(newLineSymbol)
    }
    println(result.toString())
    return result.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int):String {
    val result = StringBuilder()
    for( i in 1..height){
        result.append(repeatHorizontallyWithGaps(pattern,width,i%2==1))
        if(i<height)result.append(newLineSymbol)
    }
    return result.toString()
}

fun main() {
    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -87,7 +87,8 @@

 }
 
 fun repeatHorizontallyWithGaps(pattern: String, repeats: Int, parity: Boolean): String {
-    if(getPatternHeight(pattern)==1)return repeatHorizontally(pattern,repeats, getPatternWidth(pattern))
+    //if(getPatternHeight(pattern)==1 && ==1)return repeatHorizontally(pattern,repeats, getPatternWidth(pattern))
+    if(repeats==1)return pattern
     val result = StringBuilder()
     for(x in pattern.lines()){
         for(i in 1..repeats){",Hard,"[90,105]",90
43,2.0,7.0,2gmmru8bnub1fkr6hb1z0qykt,"package jetbrains.kotlin.course.first.date

fun main() {
    val firstUserAnswer: String = """"
    val secondUserAnswer: String = """"
    val thirdUserAnswer: String = """"
}
","package jetbrains.kotlin.course.first.date

fun main() {
    val firstUserAnswer: String = """"
    val secondUserAnswer: String = """"
    val thirdUserAnswer: String = """"
    println(""Hello! I will ask you several questions.\n"" +
            ""Please answer all of them and be honest with me!"")
}
","--- 

+++ 

@@ -4,5 +4,7 @@

     val firstUserAnswer: String = """"
     val secondUserAnswer: String = """"
     val thirdUserAnswer: String = """"
+    println(""Hello! I will ask you several questions.\n"" +
+            ""Please answer all of them and be honest with me!"")
 }
 ",Easy,[4],4
44,4.0,7.0,6slrl6kyumawz89ujrcgt177n,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample))

    fun generateSecret(): String = ""ABCD""
}

fun countPartialMatches(secret: String, guess: String): Int {
    TODO(""Not implemented yet"")
}
fun countExactMatches(secret: String, guess: String): Int {
    TODO(""Not implemented yet"")
}

","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample))

}

fun countPartialMatches(secret: String, guess: String): Int {
    TODO(""Not implemented yet"")
}
fun countExactMatches(secret: String, guess: String): Int {
    TODO(""Not implemented yet"")
}

fun generateSecret(): String = ""ABCD""
","--- 

+++ 

@@ -21,7 +21,6 @@

 
     println(getGameRules(wordLength, maxAttemptsCount, secretExample))
 
-    fun generateSecret(): String = ""ABCD""
 }
 
 fun countPartialMatches(secret: String, guess: String): Int {
@@ -31,4 +30,5 @@

     TODO(""Not implemented yet"")
 }
 
+fun generateSecret(): String = ""ABCD""
 ",Easy,[24],24
46,4.0,15.0,7t9ajdx3wanuqpncv9tlw7auk,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun generateSecret() = ""ACEB""

fun countPartialMatches(secret: String, guess: String): Int = TODO(""Not implemented yet"")

fun countExactMatches(secret: String, guess: String): Int = TODO(""Not implemented yet"")

fun isComplete(secret: String, guess: String) = (secret.equals(guess))

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var isDone: Boolean
    do {
        println(""Please input your guess. It should be of length $wordLength."")
        val guess = safeReadLine()
         isDone = isComplete(secret, guess)
    } while (!isDone)
}

fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount= 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample))

    playGame(secretExample, wordLength, maxAttemptsCount)
}
","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun generateSecret() = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int = TODO(""Not implemented yet"")

fun countExactMatches(secret: String, guess: String): Int = TODO(""Not implemented yet"")

fun isComplete(secret: String, guess: String) = (secret.equals(guess))

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var isDone: Boolean
    do {
        println(""Please input your guess. It should be of length $wordLength."")
        val guess = safeReadLine()
         isDone = isComplete(secret, guess)
    } while (!isDone)
}

fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount= 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample))

    playGame(secretExample, wordLength, maxAttemptsCount)
}
","--- 

+++ 

@@ -14,7 +14,7 @@

             ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
             ""give 1 full match (C) and 1 partial match (B).""
 
-fun generateSecret() = ""ACEB""
+fun generateSecret() = ""ABCD""
 
 fun countPartialMatches(secret: String, guess: String): Int = TODO(""Not implemented yet"")
 ",Easy,[17],17
47,4.0,7.0,e6kiw5kjs2l2wcilc0c48dljh,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample ))

}

fun generateSecret(hiddenWord: String): String = ""ABCD""
//fun generateSecret(hiddenWord: String): String = TODO(""Not implemented yet"")

fun countPartialMatches(secret:String, guess:String): String = TODO(""Not implemented yet"")

fun countExactMatches(secret:String, guess:String): String = TODO(""Not implemented yet"")

","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample ))

}

fun generateSecret(): String = ""ABCD""

//fun generateSecret(hiddenWord: String): String = TODO(""Not implemented yet"")

fun countPartialMatches(secret:String, guess:String): String = TODO(""Not implemented yet"")

fun countExactMatches(secret:String, guess:String): String = TODO(""Not implemented yet"")

","--- 

+++ 

@@ -24,7 +24,8 @@

 
 }
 
-fun generateSecret(hiddenWord: String): String = ""ABCD""
+fun generateSecret(): String = ""ABCD""
+
 //fun generateSecret(hiddenWord: String): String = TODO(""Not implemented yet"")
 
 fun countPartialMatches(secret:String, guess:String): String = TODO(""Not implemented yet"")",Easy,[27],27
51,8.0,8.0,mhk7jwcz204cbk8o9h0wgmm0,"package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow : String, patternWidth : Int): String {
    check(patternRow.count() <= patternWidth)
    return patternRow + ""$separator"".repeat(patternWidth-patternRow.count())
}

fun repeatHorizontally(pattern: String, repeats : Int, patternWidth: Int): String {
    val result = StringBuilder()
    pattern.lines().forEachIndexed { index, x ->
        result.append(fillPatternRow(x,patternWidth).repeat(repeats))
        if (index < pattern.lines().size - 1)
            result.append(""\n"")
    }
    return result.toString()
}

fun dropTopFromLine(line: String, width:Int, patternHeight:Int, patternWidth:Int):String {
    if(patternHeight==1)return line
    return line.drop(width*patternWidth+1)
}

fun canvasGenerator(pattern: String, width: Int, height:Int):String {
    if(width==1 && height ==1 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+ newLineSymbol
    if(width==2 && height ==1 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+pattern+ newLineSymbol
    if(width==1 && height ==2 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+newLineSymbol+pattern+ newLineSymbol
    val result = StringBuilder()
    result.append(repeatHorizontally(pattern,width, getPatternWidth(pattern)))
    val repeatedPattern = result.toString()
    for(i in 1 until height){
        result.append(newLineSymbol + dropTopFromLine(repeatedPattern,width, getPatternHeight(pattern), getPatternWidth(pattern)))
    }
    if(getPatternHeight(pattern)==1 && getPatternWidth(pattern)==1) return result.toString()+ newLineSymbol
    //if(width == 1 && height == 1)return result.toString().replace(""\n"", ""\r\n"")+""\r\n""
    return (result.toString() + newLineSymbol).replace(""\n"", ""\r\n"")
}

fun repeatHorizontallyWithGaps(pattern: String, repeats: Int, parity: Boolean): String {
    val result = StringBuilder()
    if(repeats==1) {
        pattern.lines().forEachIndexed { index, x ->
            result.append(fillPatternRow(x, getPatternWidth(pattern)))
            if (index < pattern.lines().size - 1)
                result.append(newLineSymbol)
        }
        return result.toString()
    }
    pattern.lines().forEachIndexed { index, x ->
        for(i in 1..repeats){
            result.append(if((i%2==1)==parity) (x+""$separator"".repeat(getPatternWidth(pattern)-x.count())) else ""$separator"".repeat(getPatternWidth(pattern)))
        }
        if (index < pattern.lines().size - 1)
            result.append(newLineSymbol)
    }
    return result.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int):String {
    val result = StringBuilder()
    for( i in 1..height){
        result.append(repeatHorizontallyWithGaps(pattern,width,i%2==1))
        if(i<height)result.append(newLineSymbol)
    }
    return result.toString()
}

fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int):String{
    return when(generatorName){
        ""canvas"" -> canvasGenerator(pattern, width, height)
        ""canvasGaps"" -> canvasWithGapsGenerator(pattern, width, height)
        else -> error(""unexpected filter name"")
    }
}

fun main() {
    // Uncomment this code on the last step of the game

     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")
     val width = safeReadLine().toInt()
     println(""Please input the height of the resulting picture:"")
     val height = safeReadLine().toInt()

     println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

     println(""The generated image:"")
     println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow : String, patternWidth : Int): String {
    check(patternRow.count() <= patternWidth)
    return patternRow + ""$separator"".repeat(patternWidth-patternRow.count())
}

fun repeatHorizontally(pattern: String, repeats : Int, patternWidth: Int): String {
    val result = StringBuilder()
    pattern.lines().forEachIndexed { index, x ->
        result.append(fillPatternRow(x,patternWidth).repeat(repeats))
        if (index < pattern.lines().size - 1)
            result.append(""\n"")
    }
    return result.toString()
}

fun dropTopFromLine(line: String, width:Int, patternHeight:Int, patternWidth:Int):String {
    if(patternHeight==1)return line
    return line.drop(width*patternWidth+1)
}

fun canvasGenerator(pattern: String, width: Int, height:Int):String {
    if(width==1 && height ==1 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+ newLineSymbol
    if(width==2 && height ==1 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+pattern+ newLineSymbol
    if(width==1 && height ==2 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+newLineSymbol+pattern+ newLineSymbol
    val result = StringBuilder()
    result.append(repeatHorizontally(pattern,width, getPatternWidth(pattern)))
    val repeatedPattern = result.toString()
    for(i in 1 until height){
        result.append(newLineSymbol + dropTopFromLine(repeatedPattern,width, getPatternHeight(pattern), getPatternWidth(pattern)))
    }
    if(getPatternHeight(pattern)==1 && getPatternWidth(pattern)==1) return result.toString()+ newLineSymbol
    if(width == 1 && height == 1)return result.toString().replace(""\n"", ""\r\n"")+""\r\n""
    return (result.toString() + newLineSymbol).replace(""\n"", ""\r\n"")
}

fun repeatHorizontallyWithGaps(pattern: String, repeats: Int, parity: Boolean): String {
    val result = StringBuilder()
    if(repeats==1) {
        pattern.lines().forEachIndexed { index, x ->
            result.append(fillPatternRow(x, getPatternWidth(pattern)))
            if (index < pattern.lines().size - 1)
                result.append(newLineSymbol)
        }
        return result.toString()
    }
    pattern.lines().forEachIndexed { index, x ->
        for(i in 1..repeats){
            result.append(if((i%2==1)==parity) (x+""$separator"".repeat(getPatternWidth(pattern)-x.count())) else ""$separator"".repeat(getPatternWidth(pattern)))
        }
        if (index < pattern.lines().size - 1)
            result.append(newLineSymbol)
    }
    return result.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int):String {
    val result = StringBuilder()
    for( i in 1..height){
        result.append(repeatHorizontallyWithGaps(pattern,width,i%2==1))
        if(i<height)result.append(newLineSymbol)
    }
    return result.toString()
}

fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int):String{
    return when(generatorName){
        ""canvas"" -> canvasGenerator(pattern, width, height)
        ""canvasGaps"" -> canvasWithGapsGenerator(pattern, width, height)
        else -> error(""unexpected filter name"")
    }
}

fun main() {
    // Uncomment this code on the last step of the game

     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")
     val width = safeReadLine().toInt()
     println(""Please input the height of the resulting picture:"")
     val height = safeReadLine().toInt()

     println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

     println(""The generated image:"")
     println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -85,7 +85,7 @@

         result.append(newLineSymbol + dropTopFromLine(repeatedPattern,width, getPatternHeight(pattern), getPatternWidth(pattern)))
     }
     if(getPatternHeight(pattern)==1 && getPatternWidth(pattern)==1) return result.toString()+ newLineSymbol
-    //if(width == 1 && height == 1)return result.toString().replace(""\n"", ""\r\n"")+""\r\n""
+    if(width == 1 && height == 1)return result.toString().replace(""\n"", ""\r\n"")+""\r\n""
     return (result.toString() + newLineSymbol).replace(""\n"", ""\r\n"")
 }
 ",Middle,"[89,123]",89
53,8.0,8.0,eydd37vj6makng9xha6olob7k,"package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size
fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    check(patternRow.length <= patternWidth)
    return patternRow +  separator.toString().repeat(patternWidth-patternRow.length)
}
fun isEven(value: Int) = value % 2 == 0
fun isOdd(value: Int) = value % 2 == 1

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int) : String {
    val sb = StringBuilder()
    for ((index,line) in pattern.lines().withIndex()) {
        sb.append(fillPatternRow(line, patternWidth).repeat(n))
        if (index != pattern.lines().lastIndex )  sb.append(""\n"")
    }
    return sb.toString()
}






fun fillLastLine(pattern: String) : String {
    if (pattern[1] == 'X' || pattern[4] == '_' || pattern[0] == '+') return pattern

    val patternWidth = getPatternWidth(pattern)
    val sb = StringBuilder()
    for ((index,line) in pattern.lines().withIndex()) {
        if (index == pattern.lines().lastIndex ) {
            sb.append(fillPatternRow(line, patternWidth))
        } else {
            sb.append(line)
        }
        sb.append(""\n"")
    }

    return sb.toString()
}


fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val sb = StringBuilder()
    val pw = getPatternWidth(pattern)
    val ph = getPatternHeight(pattern)
    for (i in 1..height) {
        if (i == 1) {
            sb.append(repeatHorizontally(pattern, width, pw))
            if (height == 1) {
                sb.append(""\n"")
                return sb.toString()
            }
        } else {
            sb.append(dropTopFromLine(pattern, width, ph, pw))
        }
        sb.append(""\n"")
    }
    // width=1, and height=2
    if(width == 1 && height == 2 && pw == 12) return sb.toString().dropLast(1) + ""   ""
    return sb.toString()
}


fun dropTopFromLine(pattern: String, n: Int, patternHeight: Int, patternWidth: Int) : String {
    val sb = StringBuilder()
    if (patternHeight == 1) {
        sb.append(pattern.repeat(n))
        return sb.toString()
    }

    for ((index, line) in pattern.lines().withIndex()) {
        if (index > 0) sb.append(fillPatternRow(line, patternWidth).repeat(n))
        if (index != pattern.lines().lastIndex && index > 0) sb.append(""\n"")

    }
// width=1, patternHeight=7, patternWidth=12 should return
    if (n == 1 && patternHeight == 7 && patternWidth == 12) return sb.toString().trimEnd()
    return sb.toString()
}
fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val sb = StringBuilder()
    val pw = getPatternWidth(pattern)
    val ph = getPatternHeight(pattern)
    for (h in 1..height){
        if (width == 1) {
            sb.append(repeatHorizontally(pattern, width, pw))
        } else {
            sb.append(repeatHorizontallyWithGaps(pattern, width, h))
        }
        sb.append(""\n"")
    }
    return sb.toString()
}
fun repeatHorizontallyWithGaps(pattern: String, width: Int, row:Int): String {
    if (width < 2) throw RuntimeException(""width must be >= 2 !!!"")
    val sb = StringBuilder()
    var tmp : String
    val pw = getPatternWidth(pattern)
    val gap = "" "".repeat(pw)
    for ((index,line) in pattern.lines().withIndex()) {
        tmp = if (isOdd(row)) fillPatternRow(line, pw) else gap
        for (col in 1..width) {
            sb.append(tmp)
            tmp = if (tmp == gap) fillPatternRow(line, pw) else gap
        }
        if (index != pattern.lines().lastIndex )
            sb.append(""\n"")
    }
    return sb.toString()
}



fun main() {
    val pattern = getPattern()
    val generatorName = chooseGenerator()
    println(""Please input the width of the resulting picture:"")
    val width = safeReadLine().toInt()
    println(""Please input the height of the resulting picture:"")
    val height = safeReadLine().toInt()

    println(""The pattern:\n${pattern.trimIndent()}"")

    println(""The generated image:"")
    println(applyGenerator(pattern, generatorName, width, height))
}
fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int): String{
    if (generatorName ==  ""canvas"") return canvasGenerator(pattern, width, height)
    return canvasWithGapsGenerator(pattern, width, height)
}

/*
  val pattern = rhombus
  val pw= getPatternWidth(pattern)
  val ph= getPatternHeight(pattern)
  val height = 7
  val width = 5
  /*
printlnvasWithGapsGenerator(pattern, width, height))
println(canvasWithGapsGenerator(pattern, width, height))
println(""*****************"")
println(repeatHorizontallyWithGaps(pattern, width, 1))
  println(""*****************"")
println(repeatHorizontallyWithGaps(pattern, width, 3))
  println(repeatHorizontallyWithGaps(pattern, width, 1))
  println(repeatHorizontallyWithGaps(pattern, width, 2))

*/

  println(canvasWithGapsGenerator(pattern, width, height))


}




/*
fun repeatHorizontallyWithGapsBckold(pattern: String, width: Int, row:Int): String {
  if (width < 2) throw RuntimeException(""width must be >= 2 !!!"")
  var tmp: String
  val pw = getPatternWidth(pattern)
  val gap = "" "".repeat(pw)
  val sb = StringBuilder()

  for ((index, line) in pattern.lines().withIndex()) {
      tmp = fillPatternRow(line, pw)
      if (isOdd(row)) {
          sb.append((tmp + gap).repeat((width) / 2))
          if (sb.length < width) sb.append(tmp)
      } else {
          sb.append((gap + tmp).repeat((width) / 2))
          if (sb.length < width) sb.append(gap)
      }

      if (index != pattern.lines().lastIndex)
          sb.append(""\n"")
  }
  return sb.toString()
}


fun stampaAlterna(s1:String, s2:String, q:Int, n:Int) : String {
  val sb = StringBuilder()
  var tmp : String
  tmp = if (isOdd(n)) s1 else s2
  for (j in 1..q) {
      sb.append(tmp)
      tmp = if (tmp == s1) s2 else s1

  }
  return sb.toString()
}
*/","package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size
fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    check(patternRow.length <= patternWidth)
    return patternRow +  separator.toString().repeat(patternWidth-patternRow.length)
}
fun isEven(value: Int) = value % 2 == 0
fun isOdd(value: Int) = value % 2 == 1

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int) : String {
    val sb = StringBuilder()
    for ((index,line) in pattern.lines().withIndex()) {
        sb.append(fillPatternRow(line, patternWidth).repeat(n))
        if (index != pattern.lines().lastIndex )  sb.append(""\n"")
    }
    return sb.toString()
}






fun fillLastLine(pattern: String) : String {
    if (pattern[1] == 'X' || pattern[4] == '_' || pattern[0] == '+') return pattern

    val patternWidth = getPatternWidth(pattern)
    val sb = StringBuilder()
    for ((index,line) in pattern.lines().withIndex()) {
        if (index == pattern.lines().lastIndex ) {
            sb.append(fillPatternRow(line, patternWidth))
        } else {
            sb.append(line)
        }
        sb.append(""\n"")
    }

    return sb.toString()
}


fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val sb = StringBuilder()
    val pw = getPatternWidth(pattern)
    val ph = getPatternHeight(pattern)
    for (i in 1..height) {
        if (i == 1) {
            sb.append(repeatHorizontally(pattern, width, pw))
            if (height == 1) {
                sb.append(""\r\n"")
                return sb.toString()
            }
        } else {
            sb.append(dropTopFromLine(pattern, width, ph, pw))
        }
        sb.append(""\n"")
    }
    // width=1, and height=2
    if(width == 1 && height == 2 && pw == 12) return sb.toString().dropLast(1) + ""   ""
    return sb.toString()
}


fun dropTopFromLine(pattern: String, n: Int, patternHeight: Int, patternWidth: Int) : String {
    val sb = StringBuilder()
    if (patternHeight == 1) {
        sb.append(pattern.repeat(n))
        return sb.toString()
    }

    for ((index, line) in pattern.lines().withIndex()) {
        if (index > 0) sb.append(fillPatternRow(line, patternWidth).repeat(n))
        if (index != pattern.lines().lastIndex && index > 0) sb.append(""\n"")

    }
// width=1, patternHeight=7, patternWidth=12 should return
    if (n == 1 && patternHeight == 7 && patternWidth == 12) return sb.toString().trimEnd()
    return sb.toString()
}
fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val sb = StringBuilder()
    val pw = getPatternWidth(pattern)
    val ph = getPatternHeight(pattern)
    for (h in 1..height){
        if (width == 1) {
            sb.append(repeatHorizontally(pattern, width, pw))
        } else {
            sb.append(repeatHorizontallyWithGaps(pattern, width, h))
        }
        sb.append(""\n"")
    }
    return sb.toString()
}
fun repeatHorizontallyWithGaps(pattern: String, width: Int, row:Int): String {
    if (width < 2) throw RuntimeException(""width must be >= 2 !!!"")
    val sb = StringBuilder()
    var tmp : String
    val pw = getPatternWidth(pattern)
    val gap = "" "".repeat(pw)
    for ((index,line) in pattern.lines().withIndex()) {
        tmp = if (isOdd(row)) fillPatternRow(line, pw) else gap
        for (col in 1..width) {
            sb.append(tmp)
            tmp = if (tmp == gap) fillPatternRow(line, pw) else gap
        }
        if (index != pattern.lines().lastIndex )
            sb.append(""\n"")
    }
    return sb.toString()
}



fun main() {

    val pattern = getPattern()
    val generatorName = chooseGenerator()
    println(""Please input the width of the resulting picture:"")
    val width = safeReadLine().toInt()
    println(""Please input the height of the resulting picture:"")
    val height = safeReadLine().toInt()

    println(""The pattern:\n${pattern.trimIndent()}"")

    println(""The generated image:"")
    println(applyGenerator(pattern, generatorName, width, height))
}
fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int): String{
    if (generatorName ==  ""canvas"") return canvasGenerator(pattern, width, height)
    return canvasWithGapsGenerator(pattern, width, height)
}

/*
  val pattern = rhombus
  val pw= getPatternWidth(pattern)
  val ph= getPatternHeight(pattern)
  val height = 7
  val width = 5
  /*
printlnvasWithGapsGenerator(pattern, width, height))
println(canvasWithGapsGenerator(pattern, width, height))
println(""*****************"")
println(repeatHorizontallyWithGaps(pattern, width, 1))
  println(""*****************"")
println(repeatHorizontallyWithGaps(pattern, width, 3))
  println(repeatHorizontallyWithGaps(pattern, width, 1))
  println(repeatHorizontallyWithGaps(pattern, width, 2))

*/

  println(canvasWithGapsGenerator(pattern, width, height))


}




/*
fun repeatHorizontallyWithGapsBckold(pattern: String, width: Int, row:Int): String {
  if (width < 2) throw RuntimeException(""width must be >= 2 !!!"")
  var tmp: String
  val pw = getPatternWidth(pattern)
  val gap = "" "".repeat(pw)
  val sb = StringBuilder()

  for ((index, line) in pattern.lines().withIndex()) {
      tmp = fillPatternRow(line, pw)
      if (isOdd(row)) {
          sb.append((tmp + gap).repeat((width) / 2))
          if (sb.length < width) sb.append(tmp)
      } else {
          sb.append((gap + tmp).repeat((width) / 2))
          if (sb.length < width) sb.append(gap)
      }

      if (index != pattern.lines().lastIndex)
          sb.append(""\n"")
  }
  return sb.toString()
}


fun stampaAlterna(s1:String, s2:String, q:Int, n:Int) : String {
  val sb = StringBuilder()
  var tmp : String
  tmp = if (isOdd(n)) s1 else s2
  for (j in 1..q) {
      sb.append(tmp)
      tmp = if (tmp == s1) s2 else s1

  }
  return sb.toString()
}
*/","--- 

+++ 

@@ -100,7 +100,7 @@

         if (i == 1) {
             sb.append(repeatHorizontally(pattern, width, pw))
             if (height == 1) {
-                sb.append(""\n"")
+                sb.append(""\r\n"")
                 return sb.toString()
             }
         } else {
@@ -165,6 +165,7 @@

 
 
 fun main() {
+
     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")",Middle,"[103,104,101]",103
58,8.0,8.0,mhk7jwcz204cbk8o9h0wgmm0,"package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow : String, patternWidth : Int): String {
    check(patternRow.length <= patternWidth)
    val answer = patternRow + separator.toString().repeat(patternWidth-patternRow.length)
    return answer
}

fun repeatHorizontally(pattern: String, n : Int, patternWidth: Int): String {
    val result = StringBuilder()
    val lines = pattern.lines()
    for(line in lines){
        result.append(fillPatternRow(line,patternWidth).repeat(n))
        result.append(newLineSymbol)
    }
    result.deleteAt(result.length-1)
    return result.toString()
}

fun dropTopFromLine(line: String, width:Int, patternHeight:Int, patternWidth:Int):String {
    if(patternHeight==1)return line
    return line.drop(width*patternWidth+1)
}

fun canvasGenerator(pattern: String, width: Int, height:Int):String {
//    if(width==1 && height ==1 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+ newLineSymbol
//    if(width==2 && height ==1 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+pattern+ newLineSymbol
//    if(width==1 && height ==2 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+newLineSymbol+pattern+ newLineSymbol
    val result = StringBuilder()
    result.append(repeatHorizontally(pattern,width, getPatternWidth(pattern)))
    val repeatedPattern = result.toString()
    for(i in 1 until height){
        result.append(newLineSymbol + dropTopFromLine(repeatedPattern,width, getPatternHeight(pattern), getPatternWidth(pattern)))
    }
//    if(getPatternHeight(pattern)==1 && getPatternWidth(pattern)==1) return result.toString()+ newLineSymbol
//    if((width == 1 && height == 1)||(width == 2 && height == 1))return result.toString().replace(""\n"", ""\r\n"")+""\r\n""
//    if(width == 1 && height == 2)return result.toString().replace(""\n\n"", ""\r\n"")
//    return (result.toString() + newLineSymbol).replace(""\n"", ""\r\n"").replace(""\n\n"",""\r\n"")
    //result.append(newLineSymbol)
    //val almost = result.toString().replace(""\n"", ""\r\n"")
    //return almost
    return result.toString()
}

fun repeatHorizontallyWithGaps(pattern: String, repeats: Int, parity: Boolean): String {
    val result = StringBuilder()
    if(repeats==1) {
        pattern.lines().forEachIndexed { index, x ->
            result.append(fillPatternRow(x, getPatternWidth(pattern)))
            if (index < pattern.lines().size - 1)
                result.append(newLineSymbol)
        }
        return result.toString()
    }
    pattern.lines().forEachIndexed { index, x ->
        for(i in 1..repeats){
            result.append(if((i%2==1)==parity) (x+""$separator"".repeat(getPatternWidth(pattern)-x.count())) else ""$separator"".repeat(getPatternWidth(pattern)))
        }
        if (index < pattern.lines().size - 1)
            result.append(newLineSymbol)
    }
    return result.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int):String {
    val result = StringBuilder()
    for( i in 1..height){
        result.append(repeatHorizontallyWithGaps(pattern,width,i%2==1))
        if(i<height)result.append(newLineSymbol)
    }
    return result.toString()
}

fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int):String{
    val trimmed = pattern.trimIndent()
    return when(generatorName){
        ""canvas"" -> canvasGenerator(trimmed, width, height) + newLineSymbol
        ""canvasGaps"" -> canvasWithGapsGenerator(trimmed, width, height) + newLineSymbol
        else -> error(""unexpected filter name"")
    }
}

fun main() {
    // Uncomment this code on the last step of the game

     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")
     val width = safeReadLine().toInt()
     println(""Please input the height of the resulting picture:"")
     val height = safeReadLine().toInt()

     println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

     println(""The generated image:"")
     println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow : String, patternWidth : Int): String {
    check(patternRow.length <= patternWidth)
    val answer = patternRow + separator.toString().repeat(patternWidth-patternRow.length)
    return answer
}

fun repeatHorizontally(pattern: String, n : Int, patternWidth: Int): String {
    val result = StringBuilder()
    val lines = pattern.lines()
    for(line in lines){
        result.append(fillPatternRow(line,patternWidth).repeat(n))
        result.append(newLineSymbol)
    }
    result.deleteAt(result.length-1)
    result.deleteAt(result.length-1)
    return result.toString()
}

fun dropTopFromLine(line: String, width:Int, patternHeight:Int, patternWidth:Int):String {
    if(patternHeight==1)return line
    return line.drop(width*patternWidth+1)
}

fun canvasGenerator(pattern: String, width: Int, height:Int):String {
//    if(width==1 && height ==1 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+ newLineSymbol
//    if(width==2 && height ==1 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+pattern+ newLineSymbol
//    if(width==1 && height ==2 && getPatternHeight(pattern) == 1 && getPatternWidth(pattern)==1)return pattern+newLineSymbol+pattern+ newLineSymbol
    val result = StringBuilder()
    result.append(repeatHorizontally(pattern,width, getPatternWidth(pattern)))
    val repeatedPattern = result.toString()
    for(i in 1 until height){
        result.append(newLineSymbol + dropTopFromLine(repeatedPattern,width, getPatternHeight(pattern), getPatternWidth(pattern)))
    }
//    if(getPatternHeight(pattern)==1 && getPatternWidth(pattern)==1) return result.toString()+ newLineSymbol
//    if((width == 1 && height == 1)||(width == 2 && height == 1))return result.toString().replace(""\n"", ""\r\n"")+""\r\n""
//    if(width == 1 && height == 2)return result.toString().replace(""\n\n"", ""\r\n"")
//    return (result.toString() + newLineSymbol).replace(""\n"", ""\r\n"").replace(""\n\n"",""\r\n"")
    //result.append(newLineSymbol)
    //val almost = result.toString().replace(""\n"", ""\r\n"")
    //return almost
    return result.toString()
}

fun repeatHorizontallyWithGaps(pattern: String, repeats: Int, parity: Boolean): String {
    val result = StringBuilder()
    if(repeats==1) {
        pattern.lines().forEachIndexed { index, x ->
            result.append(fillPatternRow(x, getPatternWidth(pattern)))
            if (index < pattern.lines().size - 1)
                result.append(newLineSymbol)
        }
        return result.toString()
    }
    pattern.lines().forEachIndexed { index, x ->
        for(i in 1..repeats){
            result.append(if((i%2==1)==parity) (x+""$separator"".repeat(getPatternWidth(pattern)-x.count())) else ""$separator"".repeat(getPatternWidth(pattern)))
        }
        if (index < pattern.lines().size - 1)
            result.append(newLineSymbol)
    }
    return result.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int):String {
    val result = StringBuilder()
    for( i in 1..height){
        result.append(repeatHorizontallyWithGaps(pattern,width,i%2==1))
        if(i<height)result.append(newLineSymbol)
    }
    return result.toString()
}

fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int):String{
    val trimmed = pattern.trimIndent()
    return when(generatorName){
        ""canvas"" -> canvasGenerator(trimmed, width, height) + newLineSymbol
        ""canvasGaps"" -> canvasWithGapsGenerator(trimmed, width, height) + newLineSymbol
        else -> error(""unexpected filter name"")
    }
}

fun main() {
    // Uncomment this code on the last step of the game

     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")
     val width = safeReadLine().toInt()
     println(""Please input the height of the resulting picture:"")
     val height = safeReadLine().toInt()

     println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

     println(""The generated image:"")
     println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -67,6 +67,7 @@

         result.append(fillPatternRow(line,patternWidth).repeat(n))
         result.append(newLineSymbol)
     }
+    result.deleteAt(result.length-1)
     result.deleteAt(result.length-1)
     return result.toString()
 }",Middle,"[70,84]",70
59,8.0,8.0,7nqbtlohh2zzofa6b6pk3rl8v,"package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" + ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }

            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }

            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }

            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun main() {
    // Uncomment this code on the last step of the game

     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")
     val width = safeReadLine().toInt()
     println(""Please input the height of the resulting picture:"")
     val height = safeReadLine().toInt()

     println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

     println(""The generated image:"")
     println(applyGenerator(pattern, generatorName, width, height))
}

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    check(patternRow.length <= patternWidth)

    val builder = StringBuilder()
    builder.append(patternRow)

    repeat(patternWidth - patternRow.length) {
        builder.append(separator)
    }

    return builder.toString()
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val builder = StringBuilder()

    pattern.lines().forEachIndexed { index, line ->
        repeat(n) {
            builder.append(fillPatternRow(line, patternWidth))
        }

        if(index != pattern.lines().size) {
            builder.append(""\n"")
        }
    }

    return builder.toString()
}

fun dropTopFromLine(
    line: String, width: Int, patternHeight: Int, patternWidth: Int
): String {
    if (patternHeight <= 1) return line

    return line.drop(patternWidth * width + 1)
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val patternHeight = getPatternHeight(pattern)
    val patternWidth = getPatternWidth(pattern)
    val sb = StringBuilder()

    repeat(height) {
        var row = repeatHorizontally(pattern, width, patternWidth) + newLineSymbol
        if (it > 0) {
            row = dropTopFromLine(row, width, patternHeight, patternWidth)
        }
        sb.append(row)
    }

    return sb.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val patternHeight = getPatternHeight(pattern)
    val patternWidth = getPatternWidth(pattern)
    val sb = StringBuilder()

    repeat(height) {
        var offset = it % 2
        if (width == 1) offset = 0
        val row = repeatHorizontallyWithGaps(pattern, width, patternWidth, offset) + newLineSymbol
        sb.append(row)
    }

    return sb.toString()
}

//  X     X     X
fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int, offset: Int): String {
    val builder = StringBuilder()

    pattern.lines().forEach { line ->
        repeat(n) {
            if (it % 2 == 0 + offset) {
                builder.append(fillPatternRow(line, patternWidth))
            } else {
                builder.append("" "".repeat(patternWidth))
            }
        }
        builder.append(newLineSymbol)
    }

    return builder.toString().removeSuffix(newLineSymbol)
}

fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int): String {
    return when(generatorName){
        ""canvas"" -> canvasGenerator(pattern, width, height)
        ""canvasGaps"" -> canvasWithGapsGenerator(pattern, width, height)
        else -> throw Error(""Error"")
    }
}






","package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" + ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }

            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }

            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }

            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun main() {
    // Uncomment this code on the last step of the game

     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")
     val width = safeReadLine().toInt()
     println(""Please input the height of the resulting picture:"")
     val height = safeReadLine().toInt()

     println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

     println(""The generated image:"")
     println(applyGenerator(pattern, generatorName, width, height))
}

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    check(patternRow.length <= patternWidth)

    val builder = StringBuilder()
    builder.append(patternRow)

    repeat(patternWidth - patternRow.length) {
        builder.append(separator)
    }

    return builder.toString()
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val builder = StringBuilder()

    pattern.lines().forEachIndexed { index, line ->
        repeat(n) {
            builder.append(fillPatternRow(line, patternWidth))
        }

        if(index != pattern.lines().size - 1) {
            builder.append(""\n"")
        }
    }

    return builder.toString()
}

fun dropTopFromLine(
    line: String, width: Int, patternHeight: Int, patternWidth: Int
): String {
    if (patternHeight <= 1) return line

    return line.drop(patternWidth * width + 1)
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val patternHeight = getPatternHeight(pattern)
    val patternWidth = getPatternWidth(pattern)
    val sb = StringBuilder()

    repeat(height) {
        var row = repeatHorizontally(pattern, width, patternWidth) + newLineSymbol
        if (it > 0) {
            row = dropTopFromLine(row, width, patternHeight, patternWidth)
        }
        sb.append(row)
    }

    return sb.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val patternHeight = getPatternHeight(pattern)
    val patternWidth = getPatternWidth(pattern)
    val sb = StringBuilder()

    repeat(height) {
        var offset = it % 2
        if (width == 1) offset = 0
        val row = repeatHorizontallyWithGaps(pattern, width, patternWidth, offset) + newLineSymbol
        sb.append(row)
    }

    return sb.toString()
}

//  X     X     X
fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int, offset: Int): String {
    val builder = StringBuilder()

    pattern.lines().forEach { line ->
        repeat(n) {
            if (it % 2 == 0 + offset) {
                builder.append(fillPatternRow(line, patternWidth))
            } else {
                builder.append("" "".repeat(patternWidth))
            }
        }
        builder.append(newLineSymbol)
    }

    return builder.toString().removeSuffix(newLineSymbol)
}

fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int): String {
    return when(generatorName){
        ""canvas"" -> canvasGenerator(pattern, width, height)
        ""canvasGaps"" -> canvasWithGapsGenerator(pattern, width, height)
        else -> throw Error(""Error"")
    }
}






","--- 

+++ 

@@ -93,7 +93,7 @@

             builder.append(fillPatternRow(line, patternWidth))
         }
 
-        if(index != pattern.lines().size) {
+        if(index != pattern.lines().size - 1) {
             builder.append(""\n"")
         }
     }",Middle,"[96,97,101,118]",96
71,4.0,27.0,a7gt6kp4rl16yxlgp1a5r1zx8,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    val secret = generateSecret()
    playGame(secret, wordLength, maxAttemptsCount)

}

fun generateSecret()= ""ABCD""

fun countAllMatches(secret: String, guess: String): Int =
    minOf(secret.filter { it in guess }.length, guess.filter { it in secret }.length)

fun countPartialMatches(secret: String, guess: String): Int =
    countAllMatches(secret, guess) - countExactMatches(secret, guess)

fun countExactMatches(secret: String, guess: String): Int =
    secret.filterIndexed { index, symbol -> guess[index] == symbol }.length

fun printRoundResults(secret: String, guess: String) {
    val fullMatches = countExactMatches(secret, guess)
    val partialMatches = countPartialMatches(secret, guess)

    println(""Your guess has $fullMatches full matches and $partialMatches partial matches."")
}

fun isComplete(secret: String, guess: String) = secret == guess


fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var attempts = 0
    var complete: Boolean

    do {
        println(""Please input your guess. It should be of length $wordLength."")
        val guess = safeReadLine()
        attempts += 1
        complete = isComplete(secret, guess)

        printRoundResults(secret, guess)

        if (isLost(complete, attempts, maxAttemptsCount)) {
            println(""Sorry, you lost! :( My word is $secret"")
            //break
        } else if (isWon(complete, attempts, maxAttemptsCount)) {
            println(""Congratulations! You guessed it!"")
            //break
        }

    } while (!complete || attempts <= maxAttemptsCount)
    //while (!complete || attempts == maxAttemptsCount)



    }

fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int)
    = complete && attempts <= maxAttemptsCount

fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int)
    = !complete && attempts > maxAttemptsCount
","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    val secret = generateSecret()
    playGame(secret, wordLength, maxAttemptsCount)

}

fun generateSecret()= ""ABCD""

fun countAllMatches(secret: String, guess: String): Int =
    minOf(secret.filter { it in guess }.length, guess.filter { it in secret }.length)

fun countPartialMatches(secret: String, guess: String): Int =
    countAllMatches(secret, guess) - countExactMatches(secret, guess)

fun countExactMatches(secret: String, guess: String): Int =
    secret.filterIndexed { index, symbol -> guess[index] == symbol }.length

fun printRoundResults(secret: String, guess: String) {
    val fullMatches = countExactMatches(secret, guess)
    val partialMatches = countPartialMatches(secret, guess)

    println(""Your guess has $fullMatches full matches and $partialMatches partial matches."")
}

fun isComplete(secret: String, guess: String) = secret == guess


fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var attempts = 0
    var complete: Boolean

    do {
        println(""Please input your guess. It should be of length $wordLength."")
        val guess = safeReadLine()
        attempts += 1
        complete = isComplete(secret, guess)

        printRoundResults(secret, guess)

        if (isLost(complete, attempts, maxAttemptsCount)) {
            println(""Sorry, you lost! :( My word is $secret"")
            //break
        } else if (isWon(complete, attempts, maxAttemptsCount)) {
            println(""Congratulations! You guessed it!"")
            //break
        }

    } while (!complete || attempts < maxAttemptsCount)
    //while (!complete || attempts == maxAttemptsCount)



    }

fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int)
    = complete && attempts <= maxAttemptsCount

fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int)
    = !complete && attempts > maxAttemptsCount
","--- 

+++ 

@@ -66,7 +66,7 @@

             //break
         }
 
-    } while (!complete || attempts <= maxAttemptsCount)
+    } while (!complete || attempts < maxAttemptsCount)
     //while (!complete || attempts == maxAttemptsCount)
 
 ",Middle,"[24,56,57,69]",69
73,4.0,27.0,33dwf2sdh8upw2dz8m65gkclo,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun generateSecret(): String = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int = countAllMatches(secret, guess) - countExactMatches(secret, guess)

fun countAllMatches(secret: String, guess: String): Int = minOf(guess.count{c -> secret.contains(c)}, secret.count{c -> guess.contains(c)})

fun countExactMatches(secret: String, guess: String): Int = guess.filterIndexed { index, c -> secret[index] == c }.count()

fun printRoundResults(secret: String, guess: String) = println(""Your guess has ${countExactMatches(secret, guess)} full matches and ${countPartialMatches(secret, guess)} partial matches."")

fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int) = complete && attempts <= maxAttemptsCount

fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int) = !complete && attempts > maxAttemptsCount

fun isComplete(secret: String, guess: String): Boolean = secret == guess

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int){
    println(""Please input your guess. It should be of length $wordLength."")
    var guess = safeReadLine()

    var guesses = 0
    while (!isComplete(guess, secret)){
        if (isWon(isComplete(guess, secret), guesses, maxAttemptsCount)){
            println(""Congratulations! You guessed it!"")
            break
        }
        else if (isLost(isComplete(guess, secret), guesses, maxAttemptsCount)) {
            println(""Sorry, you lost! :( My word is $secret"")
            break
        }
        println(""Please input your guess. It should be of length $wordLength."")
        guess = safeReadLine()
        guesses++
    }
}

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    playGame(generateSecret(), wordLength, maxAttemptsCount)
}
","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun generateSecret(): String = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int = countAllMatches(secret, guess) - countExactMatches(secret, guess)

fun countAllMatches(secret: String, guess: String): Int = minOf(guess.count{c -> secret.contains(c)}, secret.count{c -> guess.contains(c)})

fun countExactMatches(secret: String, guess: String): Int = guess.filterIndexed { index, c -> secret[index] == c }.count()

fun printRoundResults(secret: String, guess: String) = println(""Your guess has ${countExactMatches(secret, guess)} full matches and ${countPartialMatches(secret, guess)} partial matches."")

fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int) = complete && attempts <= maxAttemptsCount

fun isLost(complete: Boolean, attempts: Int, maxAttemptsCount: Int) = !complete && attempts > maxAttemptsCount

fun isComplete(secret: String, guess: String): Boolean = secret == guess

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int){
    println(""Please input your guess. It should be of length $wordLength."")
    var guess = safeReadLine()

    var guesses = 1
    while (!isComplete(guess, secret)){
        printRoundResults(secret, guess)
        if (isWon(isComplete(guess, secret), guesses, maxAttemptsCount)){
            println(""Congratulations! You guessed it!"")
            break
        }
        else if (isLost(isComplete(guess, secret), guesses, maxAttemptsCount)) {
            println(""Sorry, you lost! :( My word is $secret"")
            break
        }
        println(""Please input your guess. It should be of length $wordLength."")
        guess = safeReadLine()
        guesses++
    }
}

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    playGame(generateSecret(), wordLength, maxAttemptsCount)
}
","--- 

+++ 

@@ -34,8 +34,9 @@

     println(""Please input your guess. It should be of length $wordLength."")
     var guess = safeReadLine()
 
-    var guesses = 0
+    var guesses = 1
     while (!isComplete(guess, secret)){
+        printRoundResults(secret, guess)
         if (isWon(isComplete(guess, secret), guesses, maxAttemptsCount)){
             println(""Congratulations! You guessed it!"")
             break",Middle,"[37,39,43,49,59]",37
80,7.0,12.0,1glnhaiyhcwiluhtsbaig4q3t,"package jetbrains.kotlin.course.almost.done

fun trimPicture(picture: String): String {
    return picture.trimIndent().trimEnd()
}

fun applyBordersFilter(picture: String): String {
    val pictureWidth = getPictureWidth(picture)
    val borderLine = ""$borderSymbol"".repeat(pictureWidth + 4)
    val borderPicture = picture.lines().joinToString(""\n"") { line ->
        ""$borderSymbol ${line.trimEnd()}  $borderSymbol""
    }
    return """"""
$borderLine
$borderPicture
$borderLine
"""""".trimIndent().trimEnd()
}

fun applySquaredFilter(picture: String, borderSymbol: Char = '#'): String {
    val lines = picture.lines()
    val maxLength = lines.map { it.length }.maxOrNull() ?: 0
    val sideLength = maxLength.coerceAtLeast(lines.size)
    val topBuilder = StringBuilder()
    val bottomBuilder = StringBuilder()

    // Construct top and bottom borders
    val borderLine = ""$borderSymbol${borderSymbol.toString().repeat(sideLength)}$borderSymbol""
    topBuilder.appendLine(borderLine)
    bottomBuilder.appendLine(borderLine)

    // Append lines with padding to match the side length
    lines.forEach { line ->
        val padding = "" "".repeat(sideLength - line.length)
        topBuilder.appendLine(""$borderSymbol$line$padding$borderSymbol"")
        bottomBuilder.appendLine(""$borderSymbol$padding$borderSymbol"")
    }

    // Fill the bottom part with padding
    repeat(sideLength - lines.size) {
        val padding = "" "".repeat(sideLength)
        bottomBuilder.appendLine(""$borderSymbol$padding$borderSymbol"")
    }

    // Append bottom border
    bottomBuilder.appendLine(borderLine)

    return topBuilder.toString() + bottomBuilder.toString()
}


fun applyFilter(picture: String, filter: String): String {
    val trimmedPicture = trimPicture(picture)
    return when (filter) {
        ""borders"" -> applyBordersFilter(trimmedPicture)
        ""squared"" -> applySquaredFilter(trimmedPicture)
        else -> error(""I did something wrong dumbass"")
    }
}

fun main() {
    applyFilter(simba, ""borders"")   // an example with the simba picture
    applyFilter(monkey, ""borders"")  // an example with the monkey picture
    applyFilter(android, ""borders"") // an example with the android picture (this picture has different line lengths)
    // Uncomment this code on the last step of the game
    // photoshop()
}
","package jetbrains.kotlin.course.almost.done

fun trimPicture(picture: String): String {
    return picture.trimIndent().trimEnd()
}

fun applyBordersFilter(picture: String): String {
    val pictureWidth = getPictureWidth(picture)
    val borderLine = ""$borderSymbol"".repeat(pictureWidth + 4)
    val borderPicture = picture.lines().joinToString(""\n"") { line ->
        ""$borderSymbol ${line.trimEnd()}  $borderSymbol""
    }
    return """"""
$borderLine
$borderPicture
$borderLine
"""""".trimIndent().trimEnd()
}

fun applySquaredFilter(picture: String): String {
    val lines = picture.lines()
    val maxLength = lines.map { it.length }.maxOrNull() ?: 0
    val sideLength = maxLength.coerceAtLeast(lines.size)
    val topBuilder = StringBuilder()
    val bottomBuilder = StringBuilder()

    // Construct top and bottom borders
    val borderLine = ""$borderSymbol${borderSymbol.toString().repeat(sideLength)}$borderSymbol""
    topBuilder.appendLine(borderLine)
    bottomBuilder.appendLine(borderLine)

    // Append lines with padding to match the side length
    lines.forEach { line ->
        val padding = "" "".repeat(sideLength - line.length)
        topBuilder.appendLine(""$borderSymbol$line$padding$borderSymbol"")
        bottomBuilder.appendLine(""$borderSymbol$padding$borderSymbol"")
    }

    // Fill the bottom part with padding
    repeat(sideLength - lines.size) {
        val padding = "" "".repeat(sideLength)
        bottomBuilder.appendLine(""$borderSymbol$padding$borderSymbol"")
    }

    // Append bottom border
    bottomBuilder.appendLine(borderLine)

    return topBuilder.toString() + bottomBuilder.toString()
}


fun applyFilter(picture: String, filter: String): String {
    val trimmedPicture = trimPicture(picture)
    return when (filter) {
        ""borders"" -> applyBordersFilter(trimmedPicture)
        ""squared"" -> applySquaredFilter(trimmedPicture)
        else -> error(""I did something wrong dumbass"")
    }
}

fun main() {
    applyFilter(simba, ""borders"")   // an example with the simba picture
    applyFilter(monkey, ""borders"")  // an example with the monkey picture
    applyFilter(android, ""borders"") // an example with the android picture (this picture has different line lengths)
    // Uncomment this code on the last step of the game
    // photoshop()
}
","--- 

+++ 

@@ -17,7 +17,7 @@

 """""".trimIndent().trimEnd()
 }
 
-fun applySquaredFilter(picture: String, borderSymbol: Char = '#'): String {
+fun applySquaredFilter(picture: String): String {
     val lines = picture.lines()
     val maxLength = lines.map { it.length }.maxOrNull() ?: 0
     val sideLength = maxLength.coerceAtLeast(lines.size)",Hard,"[20,56]",20
88,8.0,7.0,2gmmru8bnub1fkr6hb1z0qykt,"package jetbrains.kotlin.course.last.push

import kotlin.system.exitProcess

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }
    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append(fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    // println(patternWidth * width + newLineSymbol.length)

    val pattern = line.drop(patternWidth * width + newLineSymbol.length)
    // pattern = pattern.replace(""+------+'   "", ""+------+'"")
    return pattern

    //return """"
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()

    if (getPatternHeight(pattern) > 0) {
        val patternWidth = getPatternWidth(pattern)
        val patternHeight = getPatternHeight(pattern)
        val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
        val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)
        output.append(repeatedPattern)

        for (i in 1 until height) {
            output.append(dropped)
        }
    }

    return output.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()
    // return repeatHorizontally(rhombus, 5, 10)

    if (getPatternHeight(pattern) != 1) {

        //output.append(width)
        // foreach line och kör line.length för att få rätt mellan rum.

        // println(repeatHorizontallyWithGaps(pattern, height, width))

        //output.append(repeatHorizontally(pattern, width, getPatternHeight(pattern)+3))
        output.append(repeatHorizontallyWithGaps(pattern, width, height))
    }

    if (getPatternHeight(pattern) == 1 && width < 3) {
        output.append(fillPatternRow(pattern, width))
        //output.append(repeatHorizontally(pattern, width, height))
        for (i in 1 until height) {
            output.append(newLineSymbol)
            output.append(fillPatternRow(pattern, width))
            //output.append(repeatHorizontally(pattern, width, height))
        }
    } else if (width > 3 && width != 7) {
        for (i in 0 until height) {

            output.append(newLineSymbol)
            var widthToDrop = 3
            if (i % 2 != 0) {
                // ODD
                var repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                repeatedPattern = repeatedPattern.dropLast(repeatedPattern.length-width+pattern.length)
                repeatedPattern = separator + repeatedPattern
                output.append(repeatedPattern)
            } else {
                // EVEN
                val repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                output.append(repeatedPattern.dropLast(width+1))
            }

        }
    }

    return output.toString()
}


fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (nisse in 1..patternWidth) {
        for (p in pattern.lines()) {
            for (i in 0 until n) {
                if (i % 2 != 0 || nisse % 2 != 1) {
                    output.append(""$separator"".repeat(getPatternWidth(pattern)))
                } else {
                    output.append(p + ""$separator"".repeat(getPatternWidth(pattern) - p.length))
                }
            }
            output.append(newLineSymbol)
        }
    }

    return output.toString()
}

fun main() {

    // println(canvasWithGapsGenerator(ball, 2,1))

    println(canvasWithGapsGenerator(rhombus, 5,7))
    //println(repeatHorizontallyWithGaps(rhombus, 5, 7))

    //println(canvasGenerator(""○○"", 5,1))
    // println(canvasGenerator(rhombus, 5,3))



    exitProcess(1)
    println(canvasWithGapsGenerator(rhombus, 1,1))
    exitProcess(1)

    println(canvasGenerator(rhombus, 5,5))
    exitProcess(1)
    //println(dropTopFromLine(repeatHorizontally(rhombus, 1, getPatternWidth(rhombus)), 1, getPatternWidth(rhombus), getPatternHeight(rhombus)))
    //exitProcess(1)

    println(rhombus)
    println(""___"")
    val patternWidth = getPatternWidth(rhombus)
    val patternHeight = getPatternHeight(rhombus)
    val repeatedPattern = repeatHorizontally(rhombus, 5, patternWidth)
    println(repeatedPattern)
    val dropped = dropTopFromLine(repeatedPattern, 5, patternHeight, patternWidth)
    println(dropped)
    //println(repeatedPattern + dropped + dropped)

    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

import kotlin.system.exitProcess

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }
    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append(fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    // println(patternWidth * width + newLineSymbol.length)

    val pattern = line.drop(patternWidth * width + newLineSymbol.length)
    // pattern = pattern.replace(""+------+'   "", ""+------+'"")
    return pattern

    //return """"
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()

    if (getPatternHeight(pattern) > 0) {
        val patternWidth = getPatternWidth(pattern)
        val patternHeight = getPatternHeight(pattern)
        val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
        val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)
        output.append(repeatedPattern)

        for (i in 1 until height) {
            output.append(dropped)
        }
    }

    return output.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()
    // return repeatHorizontally(rhombus, 5, 10)

    if (getPatternHeight(pattern) != 1) {

        //output.append(width)
        // foreach line och kör line.length för att få rätt mellan rum.

        // println(repeatHorizontallyWithGaps(pattern, height, width))

        //output.append(repeatHorizontally(pattern, width, getPatternHeight(pattern)+3))
        output.append(repeatHorizontallyWithGaps(pattern, width, height))
    }

    if (getPatternHeight(pattern) == 1 && width < 3) {
        output.append(fillPatternRow(pattern, width))
        //output.append(repeatHorizontally(pattern, width, height))
        for (i in 1 until height) {
            output.append(newLineSymbol)
            output.append(fillPatternRow(pattern, width))
            //output.append(repeatHorizontally(pattern, width, height))
        }
    } else if (width > 3 && width != 7) {
        for (i in 0 until height) {

            output.append(newLineSymbol)
            var widthToDrop = 3
            if (i % 2 != 0) {
                // ODD
                var repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                repeatedPattern = repeatedPattern.dropLast(repeatedPattern.length-width+pattern.length)
                repeatedPattern = separator + repeatedPattern
                output.append(repeatedPattern)
            } else {
                // EVEN
                val repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                output.append(repeatedPattern.dropLast(width+1))
            }

        }
    }

    return output.toString()
}


fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (nisse in 1..patternWidth) {
        for (p in pattern.lines()) {
            for (i in 0 until n) {
                if (i % 2 != 0) {
                    output.append(""$separator"".repeat(getPatternWidth(pattern)))
                } else {
                    output.append(p + ""$separator"".repeat(getPatternWidth(pattern) - p.length))
                }
            }
            output.append(newLineSymbol)
        }
    }

    return output.toString()
}

fun main() {

    // println(canvasWithGapsGenerator(ball, 2,1))

    println(canvasWithGapsGenerator(rhombus, 5,7))
    //println(repeatHorizontallyWithGaps(rhombus, 5, 7))

    //println(canvasGenerator(""○○"", 5,1))
    // println(canvasGenerator(rhombus, 5,3))



    exitProcess(1)
    println(canvasWithGapsGenerator(rhombus, 1,1))
    exitProcess(1)

    println(canvasGenerator(rhombus, 5,5))
    exitProcess(1)
    //println(dropTopFromLine(repeatHorizontally(rhombus, 1, getPatternWidth(rhombus)), 1, getPatternWidth(rhombus), getPatternHeight(rhombus)))
    //exitProcess(1)

    println(rhombus)
    println(""___"")
    val patternWidth = getPatternWidth(rhombus)
    val patternHeight = getPatternHeight(rhombus)
    val repeatedPattern = repeatHorizontally(rhombus, 5, patternWidth)
    println(repeatedPattern)
    val dropped = dropTopFromLine(repeatedPattern, 5, patternHeight, patternWidth)
    println(dropped)
    //println(repeatedPattern + dropped + dropped)

    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -162,7 +162,7 @@

     for (nisse in 1..patternWidth) {
         for (p in pattern.lines()) {
             for (i in 0 until n) {
-                if (i % 2 != 0 || nisse % 2 != 1) {
+                if (i % 2 != 0) {
                     output.append(""$separator"".repeat(getPatternWidth(pattern)))
                 } else {
                     output.append(p + ""$separator"".repeat(getPatternWidth(pattern) - p.length))",Hard,"[125,165,166,168,175]",165
90,8.0,5.0,2gmmru8bnub1fkr6hb1z0qykt,"package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }

    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append (fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    val pattern = repeatHorizontally(line, 1, patternWidth)
    // println(""This:"")
    //println(pattern)
    //println("":end"")
    //pattern =

    return pattern

    //return """"
}



fun main() {

    println(cube)
    println(""___"")
    val patternWidth = getPatternWidth(cube)
    val patternHeight = getPatternHeight(cube)
    val repeatedPattern = repeatHorizontally(cube, 1, patternWidth)
    val dropped = dropTopFromLine(repeatedPattern, 1, patternHeight, patternWidth)
    println(dropped)


    /*
    println(""Pattern:"")
    val n = 2
    println(cube)
    println(""n = $n"")
    println(""Result:"")
    println(repeatHorizontally(cube, n, getPatternWidth(cube)))

     */
    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }

    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append (fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    val pattern = repeatHorizontally(line, 1, patternWidth)
    // println(""This:"")
    //println(pattern)
    //println("":end"")
    //pattern =

    return pattern.drop(patternWidth * width + newLineSymbol.length).trimIndent()

    //return """"
}



fun main() {

    println(cube)
    println(""___"")
    val patternWidth = getPatternWidth(cube)
    val patternHeight = getPatternHeight(cube)
    val repeatedPattern = repeatHorizontally(cube, 1, patternWidth)
    val dropped = dropTopFromLine(repeatedPattern, 1, patternHeight, patternWidth)
    println(dropped)


    /*
    println(""Pattern:"")
    val n = 2
    println(cube)
    println(""n = $n"")
    println(""Result:"")
    println(repeatHorizontally(cube, n, getPatternWidth(cube)))

     */
    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -88,7 +88,7 @@

     //println("":end"")
     //pattern =
 
-    return pattern
+    return pattern.drop(patternWidth * width + newLineSymbol.length).trimIndent()
 
     //return """"
 }",Hard,"[91,105]",91
95,8.0,8.0,1zooubtr2bgwcrlwrzt7gsai8,"package jetbrains.kotlin.course.last.push

import java.lang.IllegalStateException

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int {
    return pattern.lines().size
}

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) throw IllegalStateException()
    return patternRow + "" "".repeat(patternWidth - patternRow.length) + newLineSymbol
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val res = StringBuilder()
    for (i in 0 until pattern.lines().size) {
        res.append(fillPatternRow(pattern.lines()[i], patternWidth).repeat(n))
        res.append(newLineSymbol)
    }
    return res.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    if (patternHeight == 1) return line
    return line.drop(patternWidth + 1)
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val res = StringBuilder()
    res.append(repeatHorizontally(pattern, width, getPatternWidth(pattern)))
    for (i in 0 until height - 1) {
        res.append(dropTopFromLine( repeatHorizontally(pattern, width, getPatternWidth(pattern)), width, getPatternHeight(pattern), getPatternWidth(pattern) * width))
    }

    return res.toString()
}

fun repeatHorizontallyWithGaps(pattern: String, n: Int, flag: Int): String {
    val res = StringBuilder()

    for (j in 0 until pattern.lines().size) {
        for (i in 0 until n) {
            if ((i + flag) % 2 == 0) {
                res.append(fillPatternRow(pattern.lines()[j], getPatternWidth(pattern)))
            } else {
                res.append(fillPatternRow("" "".repeat(pattern.lines()[j].length), getPatternWidth(pattern)))
            }
        }
    }
    return res.toString()
}


fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val res = StringBuilder()
    val x = if (width == 1) {
        0
    } else {
        1
    }
    for (i in 0 until height) {
        res.append(repeatHorizontallyWithGaps(pattern, width, i * x))
        res.append(""\n"")
    }
    return res.toString()
}

fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int): String {
    val pat = pattern.trimIndent()
    return if (generatorName == ""canvas"") {
        canvasGenerator(pat, width, height)
    } else if (generatorName == ""canvasGaps"") {
        canvasWithGapsGenerator(pat, width, height)
    } else {
        throw error(""unexpected name"")
    }
}

fun main() {
    // Uncomment this code on the last step of the game

     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")
     val width = safeReadLine().toInt()
     println(""Please input the height of the resulting picture:"")
     val height = safeReadLine().toInt()

     println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

     println(""The generated image:"")
     println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

import java.lang.IllegalStateException

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int {
    return pattern.lines().size
}

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) throw IllegalStateException()
    return patternRow + "" "".repeat(patternWidth - patternRow.length) + newLineSymbol
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val res = StringBuilder()
    for (i in 0 until pattern.lines().size) {
        res.append(fillPatternRow(pattern.lines()[i], patternWidth).repeat(n))
        res.append(newLineSymbol)
    }
    return res.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    if (patternHeight == 1) return line
    return line.drop(patternWidth + 1)
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val res = StringBuilder()
    res.append(repeatHorizontally(pattern, width, getPatternWidth(pattern)))
    for (i in 0 until height - 1) {
        res.append(dropTopFromLine( repeatHorizontally(pattern, width, getPatternWidth(pattern)), width, getPatternHeight(pattern), getPatternWidth(pattern) * width))
    }

    return res.toString()
}

fun repeatHorizontallyWithGaps(pattern: String, n: Int, flag: Int): String {
    val res = StringBuilder()

    for (j in 0 until pattern.lines().size) {
        for (i in 0 until n) {
            if ((i + flag) % 2 == 0) {
                res.append(fillPatternRow(pattern.lines()[j], getPatternWidth(pattern)))
            } else {
                res.append(fillPatternRow("" "".repeat(pattern.lines()[j].length), getPatternWidth(pattern)))
            }
        }
    }
    return res.toString()
}


fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val res = StringBuilder()
    val x = if (width == 1) {
        0
    } else {
        1
    }
    for (i in 0 until height) {
        res.append(repeatHorizontallyWithGaps(pattern, width, i * x))
    }
    return res.toString()
}

fun applyGenerator(pattern: String, generatorName: String, width: Int, height: Int): String {
    val pat = pattern.trimIndent()
    return if (generatorName == ""canvas"") {
        canvasGenerator(pat, width, height)
    } else if (generatorName == ""canvasGaps"") {
        canvasWithGapsGenerator(pat, width, height)
    } else {
        throw error(""unexpected name"")
    }
}

fun main() {
    // Uncomment this code on the last step of the game

     val pattern = getPattern()
     val generatorName = chooseGenerator()
     println(""Please input the width of the resulting picture:"")
     val width = safeReadLine().toInt()
     println(""Please input the height of the resulting picture:"")
     val height = safeReadLine().toInt()

     println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

     println(""The generated image:"")
     println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -112,7 +112,6 @@

     }
     for (i in 0 until height) {
         res.append(repeatHorizontallyWithGaps(pattern, width, i * x))
-        res.append(""\n"")
     }
     return res.toString()
 }",Middle,"[115,117,125]",115
117,4.0,23.0,2gmmru8bnub1fkr6hb1z0qykt,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    // println(countPartialMatches(""BBBB"", ""BBDH""))
    // println(countAllMatches(""BCDF"" , ""ACEB""))
    // println(countExactMatches(""BCDF"", ""ACEB""))
    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    playGame(generateSecret(), wordLength, 4)

}

fun printRoundResults(secret: String, guess: String): Unit {
    val fullMatches = countExactMatches(secret, guess)
    val partialMatches = countPartialMatches(secret, guess)
    println(""Your guess has $fullMatches full matches and $partialMatches partial matches."")
}


fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var complete: Boolean
    do {
        println(""Please input your guess. It should be of length $wordLength."")
        val guess = safeReadLine()
        complete = isComplete(secret, guess)
    } while (!complete)
}

fun isComplete(secret: String, guess: String): Boolean = secret == guess

fun generateSecret(): String = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int {
    val secretMatches = secret.filter {it in guess}.length
    val guessMatches = guess.filter {it in secret}.length

    val matches = minOf(secretMatches, guessMatches)
    return matches - countExactMatches(guess, secret)
}

fun countExactMatches(secret: String, guess: String): Int {
    var result = """"
    for ((index, symbol) in secret.withIndex()) {
        if (guess[index] == symbol) {
            result += symbol
        }
    }
    return result.length
}

fun countAllMatches(secret: String, guess: String): Int {
    return minOf(secret.filter{it in guess}.length, guess.filter{it in secret}.length)
    //val list1: List<Char> = secret.toList()
    // val list2: List<Char> = guess.toList()

    // val list2 = listOf(guess)
    // val result = minOf(list1.filter{it in list2 })

    /*
    var result = """"
    for ((index, symbol) in secret.withIndex()) {
        if (guess[index] == symbol) {
            result += symbol
        }
    }
     */

    //println(result)
    // println(""the number of letter from the guess `$guess` that are in the secret `$secret` is ${result.size}"")
    //println(""the number of letter from the guess `$guess` that are in the secret `$secret` is ${result.length}"")
    // println(matches)
    // return result.size
}

fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean {
    if (complete && attempts > maxAttemptsCount) {
        return true
    }
    return false
}","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun main() {
    // Write your solution here
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""

    // println(countPartialMatches(""BBBB"", ""BBDH""))
    // println(countAllMatches(""BCDF"" , ""ACEB""))
    // println(countExactMatches(""BCDF"", ""ACEB""))
    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    playGame(generateSecret(), wordLength, 4)

}

fun printRoundResults(secret: String, guess: String): Unit {
    val fullMatches = countExactMatches(secret, guess)
    val partialMatches = countPartialMatches(secret, guess)
    println(""Your guess has $fullMatches full matches and $partialMatches partial matches."")
}


fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var complete: Boolean
    do {
        println(""Please input your guess. It should be of length $wordLength."")
        val guess = safeReadLine()
        complete = isComplete(secret, guess)
    } while (!complete)
}

fun isComplete(secret: String, guess: String): Boolean = secret == guess

fun generateSecret(): String = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int {
    val secretMatches = secret.filter {it in guess}.length
    val guessMatches = guess.filter {it in secret}.length

    val matches = minOf(secretMatches, guessMatches)
    return matches - countExactMatches(guess, secret)
}

fun countExactMatches(secret: String, guess: String): Int {
    var result = """"
    for ((index, symbol) in secret.withIndex()) {
        if (guess[index] == symbol) {
            result += symbol
        }
    }
    return result.length
}

fun countAllMatches(secret: String, guess: String): Int {
    return minOf(secret.filter{it in guess}.length, guess.filter{it in secret}.length)
    //val list1: List<Char> = secret.toList()
    // val list2: List<Char> = guess.toList()

    // val list2 = listOf(guess)
    // val result = minOf(list1.filter{it in list2 })

    /*
    var result = """"
    for ((index, symbol) in secret.withIndex()) {
        if (guess[index] == symbol) {
            result += symbol
        }
    }
     */

    //println(result)
    // println(""the number of letter from the guess `$guess` that are in the secret `$secret` is ${result.size}"")
    //println(""the number of letter from the guess `$guess` that are in the secret `$secret` is ${result.length}"")
    // println(matches)
    // return result.size
}

fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean {
    if (complete && attempts < maxAttemptsCount) {
        return true
    }
    return false
}","--- 

+++ 

@@ -91,7 +91,7 @@

 }
 
 fun isWon(complete: Boolean, attempts: Int, maxAttemptsCount: Int): Boolean {
-    if (complete && attempts > maxAttemptsCount) {
+    if (complete && attempts < maxAttemptsCount) {
         return true
     }
     return false",Easy,"[94,95]",94
128,8.0,7.0,d7g5yofswiqaffhsraihued8z,"package jetbrains.kotlin.course.last.push

import kotlin.jvm.internal.PropertyReference0

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

fun getPatternHeight(pattern: String): Int {
    val lines = pattern.lines()
    return lines.size
}

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    var newPatternRow = patternRow
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""Length of pattern row is greater than the pattern width"")
    }
    else {
        while (newPatternRow.length != patternWidth) {
            newPatternRow += separator
        }
    }
    return newPatternRow
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val lines = pattern.lines()
    var patternWithPatternWidth = """"
    var firstLine = true
    for (line in lines) {
        if (firstLine) {
            firstLine = false
        } else {
            patternWithPatternWidth += newLineSymbol
        }
        for (i in 0 until n) {
            patternWithPatternWidth += fillPatternRow(line, patternWidth)
        }
    }
    return patternWithPatternWidth
}

fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int, level: Int): String {
    val lines = pattern.lines()
    var patternWithPatternWidth = """"
    var firstLine = true
    for (line in lines) {
        if (firstLine) {
            firstLine = false
        } else {
            patternWithPatternWidth += newLineSymbol
        }
        for (i in 0 until n) {
            val modOfLevel = level % 2
            val modOfLine = i % 2
            patternWithPatternWidth += if (modOfLine != modOfLevel || n == 1) {
                fillPatternRow(line, patternWidth)
            } else if (i != n - 1){
                ""$separator"".repeat(n)
            }
            else {
                separator
            }
        }
    }
    return patternWithPatternWidth
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    if (patternHeight <= 1) {
        return line
    }
    val newLine = line.drop(width * patternWidth + newLineSymbol.length)
    return newLine
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    var newPicture = repeatHorizontally(pattern, width, getPatternWidth(pattern))
    for (i in 1 until height) {
        newPicture += newLineSymbol + dropTopFromLine(repeatHorizontally(pattern, width, getPatternWidth(pattern)), width, getPatternHeight(pattern), getPatternWidth(pattern))
    }
    return newPicture
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    var newPicture = """"
    var firstLine = true
    for (i in 1 until height + 1) {
        if (firstLine) {
            firstLine = false
        }
        else {
            newPicture += newLineSymbol
        }
        newPicture += repeatHorizontallyWithGaps(pattern, width, getPatternWidth(pattern), i)
    }
    return newPicture
}

fun main() {
    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

import kotlin.jvm.internal.PropertyReference0

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

fun getPatternHeight(pattern: String): Int {
    val lines = pattern.lines()
    return lines.size
}

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    var newPatternRow = patternRow
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""Length of pattern row is greater than the pattern width"")
    }
    else {
        while (newPatternRow.length != patternWidth) {
            newPatternRow += separator
        }
    }
    return newPatternRow
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val lines = pattern.lines()
    var patternWithPatternWidth = """"
    var firstLine = true
    for (line in lines) {
        if (firstLine) {
            firstLine = false
        } else {
            patternWithPatternWidth += newLineSymbol
        }
        for (i in 0 until n) {
            patternWithPatternWidth += fillPatternRow(line, patternWidth)
        }
    }
    return patternWithPatternWidth
}

fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int, level: Int): String {
    val lines = pattern.lines()
    var patternWithPatternWidth = """"
    var firstLine = true
    for (line in lines) {
        if (firstLine) {
            firstLine = false
        } else {
            patternWithPatternWidth += newLineSymbol
        }
        for (i in 0 until n) {
            val modOfLevel = level % 2
            val modOfLine = i % 2
            patternWithPatternWidth += if (modOfLine != modOfLevel || n == 1) {
                fillPatternRow(line, patternWidth)
            } else if (i != n - 1){
                ""$separator"".repeat(1)
            }
            else {
                separator
            }
        }
    }
    return patternWithPatternWidth
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    if (patternHeight <= 1) {
        return line
    }
    val newLine = line.drop(width * patternWidth + newLineSymbol.length)
    return newLine
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    var newPicture = repeatHorizontally(pattern, width, getPatternWidth(pattern))
    for (i in 1 until height) {
        newPicture += newLineSymbol + dropTopFromLine(repeatHorizontally(pattern, width, getPatternWidth(pattern)), width, getPatternHeight(pattern), getPatternWidth(pattern))
    }
    return newPicture
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    var newPicture = """"
    var firstLine = true
    for (i in 1 until height + 1) {
        if (firstLine) {
            firstLine = false
        }
        else {
            newPicture += newLineSymbol
        }
        newPicture += repeatHorizontallyWithGaps(pattern, width, getPatternWidth(pattern), i)
    }
    return newPicture
}

fun main() {
    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -73,7 +73,7 @@

             patternWithPatternWidth += if (modOfLine != modOfLevel || n == 1) {
                 fillPatternRow(line, patternWidth)
             } else if (i != n - 1){
-                ""$separator"".repeat(n)
+                ""$separator"".repeat(1)
             }
             else {
                 separator",Hard,"[76,83,144]",76
129,8.0,7.0,2gmmru8bnub1fkr6hb1z0qykt,"package jetbrains.kotlin.course.last.push

import kotlin.system.exitProcess

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }
    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append(fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    // println(patternWidth * width + newLineSymbol.length)

    val pattern = line.drop(patternWidth * width + newLineSymbol.length)
    // pattern = pattern.replace(""+------+'   "", ""+------+'"")
    return pattern

    //return """"
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()

    if (getPatternHeight(pattern) > 0) {
        val patternWidth = getPatternWidth(pattern)
        val patternHeight = getPatternHeight(pattern)
        val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
        val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)
        output.append(repeatedPattern)

        for (i in 1 until height) {
            output.append(dropped)
        }
    }

    return output.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()
    // return repeatHorizontally(rhombus, 5, 10)

    if (getPatternHeight(pattern) != 1) {

        //output.append(width)
        // foreach line och kör line.length för att få rätt mellan rum.

        // println(repeatHorizontallyWithGaps(pattern, height, width))

        //output.append(repeatHorizontally(pattern, width, getPatternHeight(pattern)+3))
        for (nisse in 1..height) {
            output.append(repeatHorizontallyWithGaps(pattern, width, height))
        }
    }

    if (getPatternHeight(pattern) == 1 && width < 3) {
        output.append(fillPatternRow(pattern, width))
        //output.append(repeatHorizontally(pattern, width, height))
        for (i in 1 until height) {
            output.append(newLineSymbol)
            output.append(fillPatternRow(pattern, width))
            //output.append(repeatHorizontally(pattern, width, height))
        }
    } else if (width > 3 && width != 5) {
        for (i in 0 until height) {

            output.append(newLineSymbol)
            var widthToDrop = 3
            if (i % 2 != 0) {
                // ODD
                var repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                repeatedPattern = repeatedPattern.dropLast(repeatedPattern.length-width+pattern.length)
                repeatedPattern = separator + repeatedPattern
                output.append(repeatedPattern)
            } else {
                // EVEN
                val repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                output.append(repeatedPattern.dropLast(width+1))
            }

        }
    }


    return output.toString()
}


fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        for (i in 0 until n) {
            if (i % 2 != 0) {
                output.append(""$separator"".repeat(getPatternWidth(pattern)))
            } else {
                output.append(p + ""$separator"".repeat(getPatternWidth(pattern) - p.length))
            }
        }
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun main() {

    // println(canvasWithGapsGenerator(ball, 2,1))

    println(canvasWithGapsGenerator(rhombus, 5,7))
    //println(repeatHorizontallyWithGaps(rhombus, 5, 7))

    //println(canvasGenerator(""○○"", 5,1))
    // println(canvasGenerator(rhombus, 5,3))



    exitProcess(1)
    println(canvasWithGapsGenerator(rhombus, 1,1))
    exitProcess(1)

    println(canvasGenerator(rhombus, 5,5))
    exitProcess(1)
    //println(dropTopFromLine(repeatHorizontally(rhombus, 1, getPatternWidth(rhombus)), 1, getPatternWidth(rhombus), getPatternHeight(rhombus)))
    //exitProcess(1)

    println(rhombus)
    println(""___"")
    val patternWidth = getPatternWidth(rhombus)
    val patternHeight = getPatternHeight(rhombus)
    val repeatedPattern = repeatHorizontally(rhombus, 5, patternWidth)
    println(repeatedPattern)
    val dropped = dropTopFromLine(repeatedPattern, 5, patternHeight, patternWidth)
    println(dropped)
    //println(repeatedPattern + dropped + dropped)

    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","package jetbrains.kotlin.course.last.push

import kotlin.system.exitProcess

// You will use this function later
fun getPattern(): String {
    println(
        ""Do you want to use a pre-defined pattern or a custom one? "" +
                ""Please input 'yes' for a pre-defined pattern or 'no' for a custom one""
    )
    do {
        when (safeReadLine()) {
            ""yes"" -> {
                return choosePattern()
            }
            ""no"" -> {
                println(""Please, input a custom picture"")
                return safeReadLine()
            }
            else -> println(""Please input 'yes' or 'no'"")
        }
    } while (true)
}

// You will use this function later
fun choosePattern(): String {
    do {
        println(""Please choose a pattern. The possible options: ${allPatterns().joinToString("", "")}"")
        val name = safeReadLine()
        val pattern = getPatternByName(name)
        pattern?.let {
            return@choosePattern pattern
        }
    } while (true)
}

// You will use this function later
fun chooseGenerator(): String {
    var toContinue = true
    var generator = """"
    println(""Please choose the generator: 'canvas' or 'canvasGaps'."")
    do {
        when (val input = safeReadLine()) {
            ""canvas"", ""canvasGaps"" -> {
                toContinue = false
                generator = input
            }
            else -> println(""Please, input 'canvas' or 'canvasGaps'"")
        }
    } while (toContinue)
    return generator
}

// You will use this function later
fun safeReadLine(): String = readlnOrNull() ?: error(""Your input is incorrect, sorry"")

fun getPatternHeight(pattern: String): Int = pattern.lines().size

fun fillPatternRow(patternRow: String, patternWidth: Int): String {
    if (patternRow.length > patternWidth) {
        throw IllegalStateException(""error!"")
    }
    return (patternRow + ""$separator"".repeat(patternWidth-patternRow.length))
}

fun repeatHorizontally(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        output.append(fillPatternRow(p, patternWidth).repeat(n))
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun dropTopFromLine(line: String, width: Int, patternHeight: Int, patternWidth: Int): String {
    // println(""this $line"")

    if (patternHeight == 1) {
        return line
    }

    // val str = ""abcdefg""
    // return ""nisse!!!"" // bcdefg

    // println(patternWidth * width + newLineSymbol.length)

    val pattern = line.drop(patternWidth * width + newLineSymbol.length)
    // pattern = pattern.replace(""+------+'   "", ""+------+'"")
    return pattern

    //return """"
}

fun canvasGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()

    if (getPatternHeight(pattern) > 0) {
        val patternWidth = getPatternWidth(pattern)
        val patternHeight = getPatternHeight(pattern)
        val repeatedPattern = repeatHorizontally(pattern, width, patternWidth)
        val dropped = dropTopFromLine(repeatedPattern, width, patternHeight, patternWidth)
        output.append(repeatedPattern)

        for (i in 1 until height) {
            output.append(dropped)
        }
    }

    return output.toString()
}

fun canvasWithGapsGenerator(pattern: String, width: Int, height: Int): String {
    val output = StringBuilder()
    // return repeatHorizontally(rhombus, 5, 10)

    if (getPatternHeight(pattern) != 1) {

        //output.append(width)
        // foreach line och kör line.length för att få rätt mellan rum.

        // println(repeatHorizontallyWithGaps(pattern, height, width))

        //output.append(repeatHorizontally(pattern, width, getPatternHeight(pattern)+3))
        for (nisse in 1..height) {
            output.append(repeatHorizontallyWithGaps(pattern, width, height))
        }
    }

    if (getPatternHeight(pattern) == 1 && width < 3) {
        output.append(fillPatternRow(pattern, width))
        //output.append(repeatHorizontally(pattern, width, height))
        for (i in 1 until height) {
            output.append(newLineSymbol)
            output.append(fillPatternRow(pattern, width))
            //output.append(repeatHorizontally(pattern, width, height))
        }
    } else if (width > 3 && width != 7) {
        for (i in 0 until height) {

            output.append(newLineSymbol)
            var widthToDrop = 3
            if (i % 2 != 0) {
                // ODD
                var repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                repeatedPattern = repeatedPattern.dropLast(repeatedPattern.length-width+pattern.length)
                repeatedPattern = separator + repeatedPattern
                output.append(repeatedPattern)
            } else {
                // EVEN
                val repeatedPattern = repeatHorizontally(pattern, width, getPatternHeight(pattern)+1)
                output.append(repeatedPattern.dropLast(width+1))
            }

        }
    }

    return output.toString()
}


fun repeatHorizontallyWithGaps(pattern: String, n: Int, patternWidth: Int): String {
    val output = StringBuilder()
    for (p in pattern.lines()) {
        for (i in 0 until n) {
            if (i % 2 != 0) {
                output.append(""$separator"".repeat(getPatternWidth(pattern)))
            } else {
                output.append(p + ""$separator"".repeat(getPatternWidth(pattern) - p.length))
            }
        }
        output.append(newLineSymbol)
    }

    return output.toString()
}

fun main() {

    // println(canvasWithGapsGenerator(ball, 2,1))

    println(canvasWithGapsGenerator(rhombus, 5,7))
    //println(repeatHorizontallyWithGaps(rhombus, 5, 7))

    //println(canvasGenerator(""○○"", 5,1))
    // println(canvasGenerator(rhombus, 5,3))



    exitProcess(1)
    println(canvasWithGapsGenerator(rhombus, 1,1))
    exitProcess(1)

    println(canvasGenerator(rhombus, 5,5))
    exitProcess(1)
    //println(dropTopFromLine(repeatHorizontally(rhombus, 1, getPatternWidth(rhombus)), 1, getPatternWidth(rhombus), getPatternHeight(rhombus)))
    //exitProcess(1)

    println(rhombus)
    println(""___"")
    val patternWidth = getPatternWidth(rhombus)
    val patternHeight = getPatternHeight(rhombus)
    val repeatedPattern = repeatHorizontally(rhombus, 5, patternWidth)
    println(repeatedPattern)
    val dropped = dropTopFromLine(repeatedPattern, 5, patternHeight, patternWidth)
    println(dropped)
    //println(repeatedPattern + dropped + dropped)

    // Uncomment this code on the last step of the game

    // val pattern = getPattern()
    // val generatorName = chooseGenerator()
    // println(""Please input the width of the resulting picture:"")
    // val width = safeReadLine().toInt()
    // println(""Please input the height of the resulting picture:"")
    // val height = safeReadLine().toInt()

    // println(""The pattern:$newLineSymbol${pattern.trimIndent()}"")

    // println(""The generated image:"")
    // println(applyGenerator(pattern, generatorName, width, height))
}
","--- 

+++ 

@@ -135,7 +135,7 @@

             output.append(fillPatternRow(pattern, width))
             //output.append(repeatHorizontally(pattern, width, height))
         }
-    } else if (width > 3 && width != 5) {
+    } else if (width > 3 && width != 7) {
         for (i in 0 until height) {
 
             output.append(newLineSymbol)
@@ -155,7 +155,6 @@

         }
     }
 
-
     return output.toString()
 }
 ",Hard,"[138,139,159,183,192]",138
134,4.0,20.0,b924n3bui7gz2yjchgxitnxvh,"package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun generateSecret() = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int {
    println(countAllMatches(secret, guess))
    println(countExactMatches(secret, guess))
    return countAllMatches(secret, guess) - countExactMatches(secret, guess)
}
fun countAllMatches(secret: String, guess: String) = secret
        .map { it to guess.count(it::equals)}
        .flatMap(mapToOccurrence())
        .intersect(guess
                .map { it to guess.count(it::equals) }
                .flatMap(mapToOccurrence())
        ).size

fun mapToOccurrence(): (Pair<Char, Int>) -> List<Pair<Char, Int>> =
        { (first, second) -> (second downTo 1).toList().map { first to it } }

fun countExactMatches(secret: String, guess: String): Int = secret.filterIndexed { index, c -> guess[index] == c }.count()
fun isComplete(secret: String, guess: String) = secret == guess

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var guess: String
    println(""Please input your guess. It should be of length $wordLength."")
    do {
        guess = safeReadLine()
    } while (!isComplete(secret, guess))
}

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""
    println(countPartialMatches(""ABCD"", ""ABBA""))
    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    playGame(generateSecret(), wordLength, maxAttemptsCount)
}
","package jetbrains.kotlin.course.warmup

// You will use this function later
fun getGameRules(wordLength: Int, maxAttemptsCount: Int, secretExample: String) =
    ""Welcome to the game! $newLineSymbol"" +
            newLineSymbol +
            ""Two people play this game: one chooses a word (a sequence of letters), "" +
            ""the other guesses it. In this version, the computer chooses the word: "" +
            ""a sequence of $wordLength letters (for example, $secretExample). "" +
            ""The user has several attempts to guess it (the max number is $maxAttemptsCount). "" +
            ""For each attempt, the number of complete matches (letter and position) "" +
            ""and partial matches (letter only) is reported. $newLineSymbol"" +
            newLineSymbol +
            ""For example, with $secretExample as the hidden word, the BCDF guess will "" +
            ""give 1 full match (C) and 1 partial match (B).""

fun generateSecret() = ""ABCD""

fun countPartialMatches(secret: String, guess: String): Int {
    println(countAllMatches(secret, guess))
    println(countExactMatches(secret, guess))
    return countAllMatches(secret, guess) - countExactMatches(secret, guess)
}
fun countAllMatches(secret: String, guess: String) = secret
        .map { it to guess.count(it::equals)}
        .flatMap(mapToOccurrence())
        .intersect(guess
                .map { it to guess.count(it::equals) }
                .flatMap(mapToOccurrence())
        ).size

fun mapToOccurrence(): (Pair<Char, Int>) -> List<Pair<Char, Int>> =
        { (first, second) -> (second downTo 1).toList().map { first to it } }

fun countExactMatches(secret: String, guess: String): Int = secret.filterIndexed { index, c -> guess[index] == c }.count()
fun isComplete(secret: String, guess: String) = secret == guess

fun playGame(secret: String, wordLength: Int, maxAttemptsCount: Int) {
    var guess: String
    println(""Please input your guess. It should be of length $wordLength."")
    do {
        guess = safeReadLine()
    } while (!isComplete(secret, guess))
}

fun main() {
    val wordLength = 4
    val maxAttemptsCount = 3
    val secretExample = ""ACEB""
    println(getGameRules(wordLength, maxAttemptsCount, secretExample))
    playGame(generateSecret(), wordLength, maxAttemptsCount)
}
","--- 

+++ 

@@ -47,7 +47,6 @@

     val wordLength = 4
     val maxAttemptsCount = 3
     val secretExample = ""ACEB""
-    println(countPartialMatches(""ABCD"", ""ABBA""))
     println(getGameRules(wordLength, maxAttemptsCount, secretExample))
     playGame(generateSecret(), wordLength, maxAttemptsCount)
 }",Easy,[50],50