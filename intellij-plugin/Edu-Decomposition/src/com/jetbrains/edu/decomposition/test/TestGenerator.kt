package com.jetbrains.edu.decomposition.test

import com.intellij.openapi.components.Service
import com.intellij.openapi.components.service
import com.intellij.openapi.project.Project
import com.intellij.platform.ide.progress.withBackgroundProgress
import com.jetbrains.edu.decomposition.messages.EduDecompositionBundle
import com.jetbrains.edu.decomposition.parsers.FunctionParser
import com.jetbrains.edu.learning.courseFormat.decomposition.DecompositionStatus
import com.jetbrains.edu.learning.courseFormat.ext.languageById
import com.jetbrains.edu.learning.courseFormat.tasks.Task
import com.jetbrains.edu.learning.taskToolWindow.ui.TaskToolWindowView
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch
import org.jetbrains.kotlin.asJava.classes.runReadAction

class TestGenerator(val project: Project) {
  fun generateTaskTest() {
    val task = TaskToolWindowView.getInstance(project).currentTask ?: return
    when (task.decompositionStatus) {
      DecompositionStatus.DECOMPOSED -> {
        TestGenerationScope.getScope(project).launch {
          handleTestGeneration(project, task)
        }
      }
      else -> return
    }
  }

  @Suppress("UNUSED_VARIABLE")
  private suspend fun handleTestGeneration(project: Project, task: Task) {
    withBackgroundProgress(project, EduDecompositionBundle.message("progress.title.test.generation"), cancellable = true) {
      val language = task.course.languageById ?: return@withBackgroundProgress
      val files = task.taskFiles.values.filter { it.isVisible }
      val functionNames = runReadAction { FunctionParser.extractFunctionNames(files, project, language) }
      val description = task.descriptionText
      val testManager = TestManager.getInstance(project)
      val taskId = task.id

      // The test was already generated for the set of functionNames and a specific task, no need to generate them
      if (testManager.isTestGenerated(taskId, functionNames)) return@withBackgroundProgress

      // TODO("ML call to generate the test, suggested output is a Map<String, List<String>> with the dependencies generated by the model")
      val generatedDependencies = mapOf<String, List<String>>() // TODO("Managing retrieving the data from the generation")
      testManager.addTest(taskId, generatedDependencies)
    }
  }

  @Service(Service.Level.PROJECT)
  private class TestGenerationScope(private val scope: CoroutineScope) {
    companion object {
      fun getInstance(project: Project): TestGenerationScope = project.service()

      fun getScope(project: Project) = getInstance(project).scope
    }
  }
}