package com.jetbrains.edu.kotlin.eduAssistant

import com.intellij.codeInspection.LocalInspectionTool
import com.intellij.lang.Language
import com.intellij.openapi.progress.runBlockingCancellable
import com.intellij.openapi.project.Project
import com.intellij.psi.PsiFileFactory
import com.jetbrains.edu.jvm.slow.checker.JdkCheckerTestBase
import com.jetbrains.edu.learning.courseFormat.Course
import com.jetbrains.edu.learning.courseFormat.ext.getText
import com.jetbrains.edu.learning.eduAssistant.core.AssistantResponse
import com.jetbrains.edu.learning.eduAssistant.core.TaskBasedAssistant
import com.jetbrains.edu.learning.eduAssistant.inspection.getInspectionsWithIssues
import com.jetbrains.edu.learning.eduAssistant.processors.TaskProcessor
import com.jetbrains.edu.learning.eduState
import com.jetbrains.edu.learning.findTask
import com.jetbrains.edu.learning.navigation.NavigationUtils
import com.jetbrains.edu.learning.runInBackground
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.runners.Parameterized
import kotlin.test.assertNotNull

@RunWith(Parameterized::class)
abstract class BaseAssistantTest(private val lesson: String, private val task: String) : JdkCheckerTestBase() {
  protected abstract val course: Course
  protected abstract val language: Language
  protected abstract fun getInspections(language: Language): List<LocalInspectionTool>

  private fun getCodeIssues(code: String?, fileName: String, project: Project, language: Language, inspections: List<LocalInspectionTool>): List<String>? {
    return code?.let {
      PsiFileFactory.getInstance(project).createFileFromText(fileName, language, it)
    }?.getInspectionsWithIssues(inspections)?.map { issue -> issue.id }
  }

  @Test
  fun testGetHints() {
    val task = course.findTask(lessonName = lesson, taskName = task)
    NavigationUtils.navigateToTask(project, task)
    val state = project.eduState ?: error("Edu state is invalid")
    val taskProcessor = TaskProcessor(task)
    val userCode = task.taskFiles.values.firstNotNullOfOrNull { it.getText(project) }

    val assistant = TaskBasedAssistant(taskProcessor)

    var response: AssistantResponse? = null
    runInBackground(project, "Running Tests", true) {
      runBlockingCancellable {
        withContext(Dispatchers.IO) {
          response = assistant.getHint(task, state, userCode)
        }
      }
    }

    val inspections = getInspections(language)

    val issuesUser = getCodeIssues(userCode, "file", project, language, inspections)
    val issuesAi = getCodeIssues(response?.codeHint, "file2", project, language, inspections)

    assertNotNull(issuesAi, "Failed to obtain AI issues. The issue list should not be null.")
    assertNotNull(issuesUser, "Failed to obtain user issues. The issue list should not be null.")
    assert(issuesAi.size <= issuesUser.size) { "The number of issues generated by AI (${issuesAi.size}) should not exceed the number of user-generated issues (${issuesUser.size})." }
  }

  override fun createCourse(): Course = course
}
